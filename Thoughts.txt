Random thoughts for the future:

TODO:
    - Add option to display size label or not
    - Wrap labels correctly if too narrow, paired with image
    - Add 'switch' element too.
    - Support non-square SVG's
    - Upload LunaSvg changes:
        - (fixed locally) Blank canvas treated as blank
        - (fixed locally) Missing em and ex from switch statement property.cpp Length::value
        - (defer until SVG2 published?) Unknown elements treated as g
        - (fixed locally) Clear faster
        - (added locally) enumerate contours
        - Fix gradient stop offset https://github.com/fdwr/LunaSvgSampleTest/commit/8df84b5b75954ef6b439ac35427c4dd6766777fe
        - Eventually grid fitting
        - Fix "transparent" color keyword missing. Works in Chrome for SVG's exported via GraphViz. https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#transparent_keyword
        - Verify bounding box in LunaSvg https://svgwg.org/svg2-draft/single-page.html#coords-BoundingBoxes
    - Roadmap
        - Implement grid fitting spec in lunasvg https://github.com/sammycage/lunasvg
        - Implement grid fitting spec in SVG Native Viewer https://github.com/adobe/svg-native-viewer with Direct2D and GDI+
        - Implement grid fitting spec in nanosvg https://github.com/memononen/nanosvg used by WxWidgets
        - Add test collateral to verify each implementation
        - Clarify naming convention - Ask Jonathon Watts jwatt@jwatt.org https://wiki.mozilla.org/SVG:Language:Regrets#Using_hyphens_in_some_element_names
        - Publish spec rough draft
        - Implement Javascript polyfill library. Test with Blink/Chromium (Chrome/Edge/Opera), Gecko (FireFox), WebKit (Safari).
        - Perhaps augment https://pypi.org/project/svgpathtools/ and/or ImageMagick https://imagemagick.org/script/display.php
    - Documentation screenshot candidates
        - icons8-fluency-fill-color.svg lavender horizontal paint level needs proportional shear to maintain shape 24x24. The bottom edges look asymmetric at 40x40, dark purple on left
        - icons8-fluency-select-none.svg dashed dots become solid gray line 24x24
        - icons8-fluency-afro-pick 28x28 bad (24x24 good)
        - icons8-fluency-bar-chart 32x32 on black background has visible dark vertical lines due to antialiasing (MSAA would fix this)
        - icons8-google-play boundaries are dark between blue and red, needing MSAA
        - icons8-fluency-add-to-clipboard horizontal rows too much detail 16x16, needs conditional reduction
        - icons8-color-check-circle checkmark can round points only to pixel corners or centers on both axes or else 45 angle would distort
        - icons8-color-settings gear shape for displacement of gear cogs. Displacing the top/bottom cogs should display the others along their tangent.
        - icons8-applet pie chart as example where you want the circle to always be an even number of pixels to avoid blurry midline
        - icons8-libre-office-writer blue lines disappear
        - Microsoft Teams View 16x16 needs midline to be crisp, so round a multiple of 2 pixels
        - Google news.svg 18x18 show individual points snapped vs 4-part, 19x19 will have uneven stem widths horizontally vs vertically
        - YouTube apps icon 28 through 40 in waterfall
        - stackoverflow.com Inbox.svg keeping inner bottom angle at 45 degrees while moving outer angle along tangent
        - icons8-blog.svg is very blurry for 24px (all one gray streak) with dramatically looking thickness for the keys per row.
        - MicrosoftSharePointFiles.svg top right corner because aligning the edges does not align the folder corner, and there's shear
        - booth.pm assets illustration...svg show weird tiny cubic beziers in top right under the wedge which would mess with projection.
        - icons8-fluency-afro-pick.svg seam in vertical midpoint
        - icons8-fluency-right.svg alpha overlap - see right arrow tip in is thicker/darker than it should be.
        - icons8-bmo.svg eyes disappear into gray mush at 24px, despite looking okay at 20px and 28px.
        - icons8-cleaning-service.svg the rounded corners at 24px in should still be visible like 48px.
        - icons8-clip-snapping.svg the gap in between the two halfs are blurry at 16 to 24px rather than a clear gap.
        - icons8-crib.svg vertical bars completely disappear.
        - icons8-deviantart.svg should use shear for the z-like shape's horizontal bars so they follow the slope. 24x24px. First adjust-transform="bounds outward", then "round-nearest(proportional-shear=true)".
        - icons8-cheese.svg 20px left circle would be slightly distorted (an oval) if transforming entire shape.
        - icons8-violin.svg 36px the handle would be better stretched via transform along the diagonals outward.
        - transform-heart.svg has little nub on left for 24px and blurry right edge 28px.

Fix void Canvas::rgba() to use macros. canvas.cpp line 195
    plutovg-private.h
    #define plutovg_alpha_shift 24
    #define plutovg_red_shift 0
    #define plutovg_green_shift 8
    #define plutovg_blue_shift 16

Gridfitting prototype - add extended SVG attributes for gridfitting
    Anchor points
        Invisible points solely for anchoring other shape's points to
        It has no fill, stroke, or visibility.
        Bounding box and clipping path calculations do not apply (so getBBox, getBoundingClientRect, getClientRects). Though SVG editors may have a more inclusive bounding box to show anchors.
        Pointer or keyboard events do not apply.
        Anchor sets/frames contain multiple anchors, each potentially with different rounding modes
            1 point yields translation
            2 points yield uniform scaling along both axes - for asymmetric scaling, use 3 (e.g. x=10,y=20 to x=30,y=20)
            2 corner points yield nonuniform scaling along both axes
            3 points yield arbitrary transformation (asymmetric scaling, shear, rotation)
            4+ points are ignored (only the first 3 matter), but a future version could treat them like a mesh warp.
        Can the points be expressed inline, and if so, via
            (a) anchor(12 42 floor(x))
            (b) 12,42, 13,66 floor(x)
            (c) 12,42; 13,16; top,left floor(x).
        Semicolons have precedent in svg.elements.animate.keyTimes https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/keyTimes
        Semicolons are also oddly used to separate attributes inside attributes svgView(viewBox(0,0,200,200);preserveAspectRatio(none))) https://svgwg.org/svg-next/linking.html#SVGFragmentIdentifiersDefinitions
        They need not be on-contour. Indeed, for rounded rectangles, off-contour corners are desired.
        Anchor adjustments can apply to multiple objects, including ones that are far away. For example a keyboard full of keys might have only one anchor to snap a keycap to whole pixels, but every other keycap can reuse that same anchor.
    Grid fitting / object alignment / pixel snapping / fine adjustment
        Align group of objects to adjusted/aligned point
        Translate anchor and entire grouped object and then stretch by other anchor frame
        grid-transform(translate(...) scale(...))
        grid-align(...)
        grid-adjust(...)
    Rounding
        Modes:
            floor, ceil
            halves to nearest floor or ceil
            toZero, toInfinity
            inward, outward
            upward, downward, leftward, rightward
        rounding-origin for in (toward zero) and out (toward infinity) rounding, or maybe an offset inside the rounding mode. e.g. toward-zero(x 0 -23 0)
            Similar to https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin
        inward and outward rounding based on path direction clockwise vs counterclockwise
        Round relative to another point
        Round even/odd (e.g. 1/3/5 odd pixel lines to half pixel vs 2/4/6 even pixel lines to pixel intersection) grid-rounding="evenodd(2)" or odd-shift(2) or parity-shift(ppu-scale=1 postbias=0 oddshift=0.5 evenshift=0)
        Round at a fraction of the grid, such as half pixels grid-rounding="x floor half"? grid-multiple=0.5 grid-scale="0.5 0.5"? grid-transform="scale(0.5 0.5)" or just parameter to floor? floor(x 0 0 0.5) where floor(axis=xy multiple=1 prebias=0 postbias=prebias)
        No rounding mode supported for halves toward even numbers (also called "banker's rounding" or "convergent").
        Round conditionally depending on whether axis aligned. e.g. grid-rounding="axis-aligned(x) non-axis-aligned(y)"
        Reinterpret rounding direction depending on rotation or mirroring, such that a mirrored/rotated graphic looked the same as a rotated/mirrored bitmap. reinterpet-on-transform(true)
        At the lower level, these resolve to bit flags: enabled/disabled per axis, floor/ceil, enabled when axis aligned true/false, flip on winding orientation, reinterpret on transform (default true)
        Displacement/projection/widening of path up to nearest whole pixel. e.g. fattening a thin path up to a whole pixel before parity rounding. e.g. displace(axis=xy mode=ceil unscaled-bias=1 postbias=0 fraction=0.5)
    Conditional details
        Conditional visibility based on device pixels per canvas unit (PPU)
        If the condition is false, all children are hidden too (more like display:none than visibility:hidden).
        If applied to an anchor, that anchor is not considered part of the rendering tree, and any children depending on it behave like a nop.
        Possible differences:
            Omit details like drop shadow
            Perspective orientation when the icon is large, but flat when tiny (e.g. Windows 7 Notepad in Alt+Tab vs top left system icon)
            Fewer objects, such as a pad with pencil at large sizes but just the pad for smaller sizes.
    Minimum constraints
        Set minimum path width minimum-stroke-width="1px" (e.g. no thinner than 1 pixel) (or stroke-width-rounding="ceil(bias=0.5 minimum=1)")
        Ensure minimum 1-pixel gap between lines (e.g. Outlook office calendar icon)
    Not turing complete
        No loops, intermediate variables, or functions, just math statements

Read:
    A vector format for Flutter by Google - https://docs.google.com/document/d/1YWffrlc6ZqRwfIiR1qwp1AOkS9JyA_lEURI8p5PsZlg/edit#heading=h.8crpi5305nr
    Rendering good looking text with resolution-independent layout - http://people.redhat.com/otaylor/grid-fitting/
    https://yqnn.github.io/svg-path-editor/
    https://svg-path-visualizer.netlify.app/
    Understanding grid sizes of (SVG) icons - https://makandracards.com/makandra/467222-understanding-grid-sizes-of-svg-icons

Investigate callstack for pixel coordinate rounding / grid-fitting:
    lunasvgtest.exe!sw_ft_outline_convert(const plutovg_path* path, const plutovg_matrix_t* matrix) Line 128
    lunasvgtest.exe!plutovg_rle_rasterize(plutovg_rle_t* rle, const plutovg_path* path, const plutovg_matrix_t* matrix, const plutovg_rect_t* clip, const plutovg_stroke_data_t* stroke, plutovg_fill_rule_t winding) Line 268
    lunasvgtest.exe!plutovg_fill_preserve(plutovg* pluto) Line 464
    lunasvgtest.exe!plutovg_fill(plutovg* pluto) Line 426
    lunasvgtest.exe!lunasvg::Canvas::fill(const lunasvg::Path& path, const lunasvg::Transform& transform, lunasvg::WindRule winding, lunasvg::BlendMode mode, double opacity) Line 111
    lunasvgtest.exe!lunasvg::FillData::fill(lunasvg::RenderState& state, const lunasvg::Path& path) Line 332
    lunasvgtest.exe!lunasvg::LayoutShape::render(lunasvg::RenderState& state) Line 409
    lunasvgtest.exe!lunasvg::LayoutContainer::renderChildren(lunasvg::RenderState& state) Line 88
    lunasvgtest.exe!lunasvg::LayoutGroup::render(lunasvg::RenderState& state) Line 180
    lunasvgtest.exe!lunasvg::LayoutContainer::renderChildren(lunasvg::RenderState& state) Line 88
    lunasvgtest.exe!lunasvg::LayoutSymbol::render(lunasvg::RenderState& state) Line 160
    lunasvgtest.exe!lunasvg::Document::render(lunasvg::Bitmap bitmap, const lunasvg::Matrix& matrix, unsigned int backgroundColor) Line 212

    lunasvgtest.exe!lunasvg::to_plutovg_path(plutovg* pluto, const lunasvg::Path& path) Line 293
    lunasvgtest.exe!lunasvg::Canvas::fill(const lunasvg::Path& path, const lunasvg::Transform& transform, lunasvg::WindRule winding, lunasvg::BlendMode mode, double opacity) Line 106
    lunasvgtest.exe!lunasvg::FillData::fill(lunasvg::RenderState& state, const lunasvg::Path& path) Line 332
    lunasvgtest.exe!lunasvg::LayoutShape::render(lunasvg::RenderState& state) Line 409
    lunasvgtest.exe!lunasvg::LayoutContainer::renderChildren(lunasvg::RenderState& state) Line 88
    lunasvgtest.exe!lunasvg::LayoutGroup::render(lunasvg::RenderState& state) Line 180
    lunasvgtest.exe!lunasvg::LayoutContainer::renderChildren(lunasvg::RenderState& state) Line 88
    lunasvgtest.exe!lunasvg::LayoutSymbol::render(lunasvg::RenderState& state) Line 160
    lunasvgtest.exe!lunasvg::Document::render(lunasvg::Bitmap bitmap, const lunasvg::Matrix& matrix, unsigned int backgroundColor) Line 212

    lunasvgtest.exe!plutovg_matrix_map_point(const plutovg_matrix_t* matrix, const plutovg_point_t* src, plutovg_point_t* dst) Line 128
    lunasvgtest.exe!sw_ft_outline_convert(const plutovg_path* path, const plutovg_matrix_t* matrix) Line 108
    lunasvgtest.exe!plutovg_rle_rasterize(plutovg_rle_t* rle, const plutovg_path* path, const plutovg_matrix_t* matrix, const plutovg_rect_t* clip, const plutovg_stroke_data_t* stroke, plutovg_fill_rule_t winding) Line 268
    lunasvgtest.exe!plutovg_fill_preserve(plutovg* pluto) Line 464
    lunasvgtest.exe!plutovg_fill(plutovg* pluto) Line 426

Bikeshed terms:
    adjustment - Small alteration or movement made to achieve a desired fit, appearance, or result. (see font-size-adjust - https://developer.mozilla.org/en-US/docs/Web/CSS/font-size-adjust)
    alignment - arrangement in a straight line, or in correct or appropriate relative positions. (see text-align - https://developer.mozilla.org/en-US/docs/Web/CSS/text-align)
    anchor - Provide with a firm basis or foundation. A heavy object attached to a rope or chain and used to moor a vessel to the sea bottom. (see text-anchor - https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/text-anchor). *One downside is that Adobe Illustrator uses anchor point to mean *any* point along a curve, which could confuse graphic designers. -_-
    arrangement - Action, process, or result of arranging or being arranged.
    attachment - An extra part or extension that is or can be attached to something to perform a particular function.
    ballast - Heavy material, such as gravel, sand, iron, or lead, placed low in a vessel to improve its stability.
    binding - Material or device used to bind such as the cover and materials that hold a book together.
    buttress - Architectural structure built against or projecting from a wall which serves to support or reinforce the wall.
    contract - decrease in size, number, or range.
    delta - Difference between two things or values.
    dilate - make or become wider, larger, or more open. (common binary image operation https://hcimage.com/help/Content/Quantitation/Measurements/Processing%20and%20Analysis/Modify/Copy%20of%20Binary_Operations.htm)
    displace - Cause (something) to move from its proper or usual place.
    displacement - The moving of something from its place or position.
    erode - gradually destroy or be gradually destroyed. (common binary image operation https://hcimage.com/help/Content/Quantitation/Measurements/Processing%20and%20Analysis/Modify/Copy%20of%20Binary_Operations.htm)
    expand - become or make larger or more extensive.
    fastener - Device that closes or secures something. Any of various devices, as a snap or hook and eye, for holding together two objects.
    fit - Fix or put (something) into place. be of the right shape and size for.
    fitment - Thing fitted to another in order to accomplish a specific purpose. The proper positioning and orientation of a thing for it to serve its designed purpose.
    fixture - Piece of equipment or furniture which is fixed in position in a building or vehicle.
    frame - Rigid structure that surrounds or encloses something such as a door or window.
    grapnel - Device consisting essentially of one or more hooks or clamps, for grasping or holding something.
    grow - become larger or greater over a period of time; increase.
    hook - Piece of metal or other material, curved or bent back at an angle, for catching hold of or hanging things on.
    keypoint - Characteristic point of interest.
    node - Point at which lines or pathways intersect or branch; a central or connecting point.
    nudge - a light touch or push.
    orthogonal - of or involving right angles; at right angles.
    pillar - Tall vertical structure of stone, wood, or metal, used as a support for a building, or as an ornament or monument.
    project - Extend outward beyond something else; protrude.
    protrude - Extend beyond or above a surface.
    rig - Particular way in which a sailboat's masts, sails, and rigging are arranged.
    rigging - Network used for support and manipulation (as in theater scenery). The system of ropes, cables, or chains employed to support a ship's masts.
    shift - move or cause to move from one place to another, especially over a small distance. a slight change in position, direction, or tendency.
    shrink - become or make smaller in size or amount.
    support - Thing that bears the weight of something or keeps it upright.
    tweak - improve (a mechanism or system) by making fine adjustments to it.
    warp - Twist or distortion in the shape or form of something.

Elements:
    <anchor/> - invisible point for other shapes to align/fit to. Can be used directly in an adjustment attribute (simple translation) or as part of an <anchorTransform/>.
        id = name of element, which can be referred by other object's grid adjust attribute.
        x = horizontal coordinate. Can be a number (user coordinates), percentage (relative to containing object or viewport), or keyword (top/bottom/left/right, relative to containing object or viewport).
        y = vertical coordinate. Like x.
        grid-rounding = Reference to a grid-rounding element #id or a series of formulas inline.
        grid-anchor-units = Sets how percentages are interpreted, with the default being relative to the containing object ('objectBoundingBox', see https://www.w3.org/TR/SVG11/coords.html#ObjectBoundingBoxUnits).
    <anchorTransform/> - a microtransform constructed from anchor points (1 point to 4 points) used for other shapes to align/fit to. It can technically be any affine transform (translation, scaling, rotation, shear, squeeze), but it's really intended for orthogonal and angle-preserving transformations (translation, uniform scaling, non-uniform scaling, and squeeze transforms. A 4th point can be used to use "in" and "out" grid rounding mode.
        anchorTransform's can be used in adjustment attributes by id name.
        id = name of element, which can be referred by other object's adjustment attributes.
        points = list of points, semicolon delimited
        points/anchors/anchor-list = semicolon delimited. list of anchors by id. possibly inline points.
        <anchor/> = nested child elements.
        grid-anchor-units = Sets how percentages are interpreted, with the default being relative to the containing object ('objectBoundingBox', see https://www.w3.org/TR/SVG11/coords.html#ObjectBoundingBoxUnits).
        [naming?] grid-anchor-frame, anchor-set
    <rounding/> - rounding adjustment via floor/ceiling, bias, scale multiplier, and optional transform to round along a specific vector rather than purely axis aligned. Rounding definitions in the <defs> section can be used by named id. Then you can just say <rect transform-adjust="#adjustmentname1" point-adjust="#adjustmentname2" .../>
        id = name of element, which can be referred by other object's grid-round attribute.
        axes = xy, x, y, stroke-width.
        mode = none/floor/ceil/towardZero/towardInfinity (no round to nearest evens, which yields an uneven staggered appearance)
            none - no grid rounding along x or y. e.g "x none; y floor"
            floor - round to nearest integer toward negative infinity (equivalent to floor(xy)). Can specify prebias, scale, and postbias: floor(x 0.5 2 -0.5) ceil(y) What about a freedom vector to round along, like 45 degrees? Named parameters? floor(axis:x prebias:0.5 scale:2 postbias:-0.5)
            ceil -  round to nearest integer toward positive infinity
            toInfinity - round away from zero (toward positive or negative infinity) to nearest integer. Equals iif(x > 0, ceil(x), floor(x)).
                Maybe "outward" suffices? We definitely need something for horizontally symmetric objects so both sides round the same direction toward or away from the center.
                How does bias interact with outward? Does the signs of prebias and postbias negate if the direction changes?
            toZero - round toward zero to nearest integer (equivalent to to-zero-y and to-zero-y). Also called "truncation". Equals iif(x > 0, floor(x), ceil(x)).
        bias = combo of both that applies to both prebias and postbias. e.g. bias(0.5) equivalent to prebias(-0.5), postbias(0.5). bias differs from transform's "translate" in that both x and y use a single value, whereas transform's "translate" treats an absent y value as 0 (not helpful here). https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform
        prebias = amount to add (subtract?) to coordinate before applying scale
        postbias = amount to add (subtract?) to coordinate after applying rounding and scale. If single parameter, then it's the x/y/xy value. If two passed, x then y. If 6 passed, then it is the full transform including proportional shift. Passing 6 values doesn't feel like just a "bias" anymore; maybe rename to "transform" there.
        unscaledBias = ...
        multiple = a scale factor to divide by before flooring/ceiling, and then remultiply (e.g. to floor to the nearest multiple of 2). There is no prescale/postscale equivalent to bias, as it would yield nonsense. [naming] Prefer multiple over divisor (used in feConvolveMatrix) even though it is used as a divisor, because it's also used as a multiplier later.
        transform = a transform to multiply the point by before rounding. The value transform=matrix(1 1 -1 1 0 0) turns it 45 degrees CCW to align along diagonal lines (equal to rotate(45deg) scale(1.414213562)). Similarly transform=[rotate(26.565051177) scale(1.118033989)] and transform=matrix(2 1 -1 2 0 0) aligns points along a 2:1 slope.
            TODO: How to align 2:1 slopes to other edges, like the bottom? Is a transform-origin needed?
        fraction = fractional amount (0 to 1, default = 1) to linearly interpolate between the original position and the rounded position. This is mainly used to round halfway.
        transformReinterprets - true/false - the world transform reinterprets the rounding mode when rotated or mirrored, swapping axes for 90/270 or reversing floor/ceil for 180 or mirroring. *naming: transform-inversion:applied/ignored, reorient-by-transform, transform-reorients
        requireAxisAlignmentment - true/false - round-if-axis-aligned? only apply the rounding when it is axis aligned, including straight lines (horizontal/vertical) and bezier nodes with straight handles.
        directionInverts - true/false - the line direction reverses interpretation. e.g. floor(x) is treated as ceil(x) for a line going up (negative) vs down (positive). Otherwise ceil is ceil, floor is floor. *naming: invert-by-direction?
        windingInverts - true/false - treat direction-inverted so that lines going down as reverse interpretation. Unclosed paths or polylines are treated as if closed. Note the original path winding in design space is used (not the path winding after world transformation, which flips when mirrored).
            [name?] windingAffect=invert/none directionAffect=invert/none axisAlignmentment=required or axisAffect=alignedOnly or orthogonality=required
        proportionalShear - true/false. "tangent"? adjust the axis proportional to the displacement of the other axis, following the contour of the vertex. e.g. Consider the letter A's T-junction on the horizontal bar, where aligning y vertically to a whole pixel without also adjusting x would distort the shape and give an awkwardly thin/thick stem near that T junction. proportion(0.2 1)
        [naming?] Adjustment? Should rounding and adjustment be unified somehow? They are basically the same thing except that rounding applies to points inside a polygon, but adjustments apply to a whole shape and yield a transform.
    <transform/> - element in defs to define a named series of transformations. That named transform can then be used in any transform attribute, including the transform of rounding.
        id = name of element, which can be referred by other object's transform attribute.
        value = a series of operations (e.g. scale, translate, rotate, shear) that modify the transformation.
        e.g. <transform id="foo" value="scale(2) translate(13 42) rotate(45)"/>
    <adjustments/> - define a reusable series of adjustments, which can be include rounding, anchors, and transforms (maybe?).
        id = name of element, which can be referred by other object's transform attribute.
        value = a series of operations (e.g. scale, translate, rotate, shear) that modify the transformation.
        e.g. <adjustments id="foo" value="centerRoundNearest #boundsOutward displace(1)"/>
    ?<displacement/> - very similar to round. Can it be joined? Should it be joined?
    ?<roundParity/> - very similar to round. Can it be joined? Should it be joined?

Attributes:
    *.ppuRange - display the object if the pixels per unit is within this range (upper bound exclusive). Can be used inside a switch statement or by itself (alternate name required-ppu?). This level of detail enables small blurry details to hide.
    *.gridAdjust/align/fit/transformAdjust - fit shape to anchor points via translation and/or scaling (stretch/scale) given anchor ids. todo: Only anchor names or coordinates? It may be convenient, but mixing the two would be confusing. Naming: grid-align? grid-adjust? grid-nudge? grid-distort?
        Anchors and anchor frames may be referenced by id. Only id's of type anchors and anchor frames may be used, not arbitrary objects. https://www.w3.org/TR/SVG/linking.html
        References may not be circular and cannot refer to parent elements (which would yield a paradox because the parent alignment already affects the children)
        Invalid/non-existent references are treated as nops
        Require prefix # before name?
        Can you mix coordinates, percentages, keywords, and anchor names? e.g. grid-adjust="50%,top #firstAnchor 42,0%"
        How about rounding mode too, which would be very concise? e.g. grid-adjust="top nearest-edge-upward"
        Or should rounding be a separate attribute? grid-adjust="top" grid-adjust-rounding="nearest-edge-upward"
        [naming] "adjustment" would be more consistent with the general nounness of attributes, but there's already precedent for "adjust" in "font-size-adjust" and "lengthAdjust".
            font-size-adjust is problematic because if you want to round the font size, it may conflict with the existing property unless both the old and the new operators are supported in the same property.
        [naming] Should it just be "grid-transform" since anchors and anchor-frames yield transforms?
    *.gridOrigin - relative origin in user coordinates. e.g. <anchor id="foo" x="13" y="42" origin="bar"/>. When anchor names are given, it's relative to the snapped position, not the original user coordinates.
    *.gridOffset - adjustment in device pixels, such as shifting to a half pixel. todo: just use grid-rounding prebias and postbias instead?
    *.gridScale - multiplier for the device grid, such as rounding to every half pixel instead.
    *.gridTransform - apply multiple transformation matrix operations (scale, offset, shear) to the grid's tranform (not the general shape transform).
        [naming] transformAdjust.
        This is an auto-reset property applicable to only the current object and not inherited (like transform).
    -*.gridRounding - left/right/up/down/in/out/floor/ceil/to-infinity/to-zero (combined modes: nearest-left, center-down, nearest-center-right, evenodd, evenodd-left)
    *.anchorAdjustment - specific to anchors without interfering with grid-rounding, which is useful for inline anchors where applying both can yield detrimental results. Defaults to inherit-grid-rounding. Can use any values from grid-rounding.
    *.shapeAdjustment - specific to anchors without interfering with grid-rounding, which is useful for inline anchors where applying both can yield detrimental results. Defaults to inherit-grid-rounding. Can use any values from grid-rounding.
    *.strokeAdjustment - like grid-rounding and anchor-rounding but specific to stroke width. Useful for ensuring minimum 1px strokes and pixel integer stroke widths. e.g. <circle stroke="..." stroke-rounding="ceil" />
    *.anchorPoints - shorthand inline form rather than declaring a separate <anchor/> with id and grid-fit/grid-align attribute in the shape. The shorthand accepts % relative to the shape bounds.
        direction keyword | <length> | <percentage>
        Maybe accept keywords left/top/center/right/bottom too like https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin.
    path.anchorList - list of anchor id's used within the path (referred to by number 0 to N-1 in the path string).
        [naming?] anchors? adjustment-list? adjustments?
    path.d - augmented to include new per-point anchors. Existing path letters include "MmLlHhVvCcSsQqTtAaZz". So maybe use "ga" and "gf" (grid align and grid fit) or "Gg" (for grid) or "f" (for fit) or "ps" (for pixel snap) or "an" for "anchor". "r" for rounding?
    framePoints - list in an anchor element of x,y coordinates (first three 3 are used for computing affine transformation).
    frameList - list of id's of other anchors that comprise this anchor. Note the comprising anchors already had a grid-rounding applied where they were defined, making any grid-rounding on this anchor element irrelevant. naming? uses=""? using=""? Not href because it shouldn't be an xlink.
    anchor.enclosingRegion - a path statement that encloses applicable points affected by that anchor. Only used by editors and tooling, not renderers, to quickly assign nodes in paths to all respective overlapping points. *naming: applicable-region?
    anchor.adjustmentUnits - objectBoundingBox or userSpaceOnUse, like "gradientUnits" https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementGradientUnitsAttribute. objectBoundingBox is the default (see https://www.w3.org/TR/SVG11/coords.html#ObjectBoundingBoxUnits), at least inherited within the context of a <defs>. Perhaps in the main body, it defaults to the SVG canvas.
        Objects with display=none are ignored. Objects with visibility=hidden or opacity/fill-opacity=0 are still counted (as they take up space in layout calculations https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/visibility).
        For objectBoundingBox, the union of the bounds of all contained objects are considered (as using the individual objects would be useless). This differs from fill painting where each object inherits the fill property and independently .
    *.anchor? - Instead of "adjust" e.g. <rect anchor="top" transform-adjust="upward"/> or just stick with <rect transform-adjust="top floor"/>? or <rect transform-adjust="anchor(top floor)"/>?
    *.transform - include origin(). e.g. <rect ... transform="origin(13 42) scale(...) rotate(...)" />. Is an existing transform-origin is replaced or accumulated? If multiple origin statements exist inside the transform, do they accumulate or reset? Should that choice be consistent between the two?

    todo: elements-like-this or elementsLikeThis? SVG is a goofy mix of the two, both camel-case and hypenated/kebab case.
        "Property or method names start with the initial keyword in lowercase, and each subsequent word starts with a capital letter." https://svgwg.org/svg2-draft/types.html#SVGDOMNamingConventions
        "Most SVG elements use camel case naming, but some use hyphenation instead ... [which] makes these SVG elements totally inconsistent with other SVG elements" https://wiki.mozilla.org/SVG:Language:Regrets#Using_hyphens_in_some_element_names
        "Best Naming Practices ... Avoid '-'" https://www.w3schools.com/xml/xml_elements.asp

Adjustments:
    grammar
        parameterValue = number | true | false | list
        list = "[" number* "]"
        positionalParameterValue = parameterValue
        namedParameter = identifier
        functionName = identifier
        functionCall = functionName "(" positionalParameterValue* [namedParameter "=" parameterValue]* ")"
    rounding: e.g.
        `floor(x 0.5 2 -0.5) ceil(y)`
        `up left`
        `x floor prebias(0.5) multiple(2) postbias(-0.5); y ceil`
        `up left`
        `floor(xy 0.5 0.5 2)`
        `transform(1 1 -1 1 0.5 0.5)` or restrict to attribute inside round to ensure symmetry round(axis=xy mode=ceil transform=[1 1 -1 1 0.5 0.5])
        `uberround()`
        main equation of uberround:
            if rounding requires axis alignment (axis orthogonality)
                if neither edge adjacent to point is axis aligned (0, 90, 180, 270), return
                otherwise at least one edge is axis aligned, and so proceed, locking the other one
            subtract grid origin (if present)
            if transform reinterpretation matters
                swap axes if rotated 90 or 270 (x<->y)
                mirror axes if mirrored or rotated 180 (x=-x, y=-y)
            if direction inversion matters
                if line direction negative xor winding direction inverted
                    reverse mode function (ceil<->floor)
            if explicit vector given (not just [1 0])
                build 2D transform matrix from vector by rotating 90 CW matrix [[0 1],[-1 0]].
                    [1 0]->[0 1], yielding [[1 0],[0 1]] which is identity.
                    [1 1]->[-1 1], yielding [[1 1],[-1 1]] which rotates 45 CW and scales 1.414x.
                multiply coordinates by built transform
            if unscaled bias given
                scaled-bias = ppu * unscaled-bias
                prebias += scaled-bias
                postbias += scaled-bias
                todo: Where does "bias-modulo" fit into this? Should it apply to just (ppu * unscaled-bias) or the whole (prebias + scale-bias)?
                should this be a separate function, not jamming it into the already complex round?
            roundedCoordinateValue = modeFunction((originalCoordinateValue - prebias) / scale) * scale + postbias
            if explicit vector given, unmultiply
            if should apply shear based on edge angle (proportional-shear=true)
                orthogonalAxisValue += (roundCoordinateValue - originalCoordinateValue) * slope of perpendicular edge
            zero delta for locked axis values
            todo: consider minimum delta (e.g. ensuring at least one pixel displacement for line thickness)
            newCoordinateValue = lerp(roundedCoordinateValue, newCoordinateValue, fraction) // where default fraction = 1
            readd grid origin (if present)
            todo: consider a means to round shapes to nearest left or right edge depending on which is nearer (e.g. a 1.5 pixel wide vertical line left or right)
    displacement
        main equation of displacement:
            create two temporary points at the current vertex
            compute the normal vectors for both edges
            determine rounding using similar rules to rounding (rounding mode, bias, scale...)
            adjust each point along the normal vector, respecting the applies=before/after
            compute the new vertex using the intersection of the two adjusted points
            todo: prevent shape inversions by clamping if the edge would become negative?
            todo: should be a similar equation to uberround, maybe even the same but with one additional boolean parameter to follow the path perpendicular automatically rather than an explicit vector
            todo: for minimum displacement (e.g. keep path at least 1px thick), how should it interact with bias and unscaled bias? With vector? Before or after the vector scaling?
    transform order:
        1.  world transform              [[sx, hy ], [hx, sy ], [dx, dy ] nop if identity
            (now in screen space)
        2.  anchor(s) grid fit/align/adjustment
            a. nop                       [[1,  0  ], [0,  1  ], [0,  0  ] nop
            b. translate                 [[1,  0  ], [0,  1  ], [dx, dy ]
            c. scale & translate         [[s,  0  ], [0,  s  ], [dx, dy ]
            d. arbitrary                 [[sx, hy ], [hx, sy ], [dx, dy ]
        3.  ppu stroke widening/thinning [[1,  0  ], [0,  1  ], [ppu*dx, ppu*dy ] perpendicular to line segments
        4.  anchor delta multiplier      [[sx, hy ], [hx, sy ], [0,  0  ] perpendicular to line segments, used to push out vertices proportional to anchor displacement
        5.  ?scaled prebias(sx hy hx sy) [[sx, hy ], [hx, sy ], [0,  0  ] possibly a way to implement grid snapping to 45 degree angles like a checkmark?
        6.  prebias(dx dy)               [[1,  0  ], [0,  1  ], [dx, dy ] nop if dx = 0 and dy = 0
        7.  inverse scale(s)             [[1/s,0  ], [0,  1/s], [0,  0  ] nop if s = 1 todo: *is s affected by MSAA multisampled antialiasing?
        8.  floor/ceil/none              [[1,  0  ], [0,  1  ], [dx, dy ] nop if 'none' rounding mode
        9.  size scale(s)                [[s,  0  ], [0,  s  ], [0,  0  ] nop if s = 1
        10. delta multiplier(dx dy)      [[sx, hy ], [hx, sy ], [0,  0  ] nop if identity (useful for proportional delta multiple)
        11. postbias(dx dy)              [[sx, hy ], [hx, sy ], [dx, dy ] nop if identity todo: *scale by MSAA factor?
        12. minimum distance             [[1,  0  ], [0,  1  ], [dx, dy ] not useful unless a relative grid-origin is specified
        ? can prebias/postbias refer to an anchor name? e.g. prebias(someAnchor) It could be useful to align one shape to another or to force a minimum distance.
    operators:
        even - todo: somehow turn this into evenodd scaled by current ppu (pixels per unit/user coordinate).
        odd - todo: somehow turn this into evenodd scaled by current ppu (pixels per unit/user coordinate).
            compute an additional bias to add to prebias and postbias based on the PPU-scaled value of some other length metric (e.g. stroke width or shape height).
            By default, ppu-shift-scale = 0, ppu-shift-bias = 0, ppu-shift-modulo = 2, scale = 0.5. For even multiples, the shift is 0. For odd multiples, the shift is 0.5, which aligns 1px strokes well.
            [naming?] bias-modulo? "size" instead of ppu-shift-scale? Is it even necessary to have a ppu-shift-bias and ppu-shift-scale? Can there just be a ppu-scaled-bias? Or even bias-unscaled, since it's in raw user coordinates before being scaled by PPU to pixels.
            ? Should modulo apply to the unscaled bias or the sum of unscaled bias and scaled bias?
        min? - todo: somehow integrate minimum distance from other anchors into this. Can this be achieved via prebias and scale instead? e.g. for min(2 otherAnchor) use prebias(-otherAnchor) scale(2) prebias(otherAnchor).
            Should it only apply to anchors?
            Should it be a separate attribute and not part of grid rounding? minimumDistance(x,y,dist) = iif(dist > 0, max(x + dist, y), iif(dist < 0, min(x + dist, y), y);
        transformReinterprets - true/false - the world transform reinterprets the rounding mode when rotated or mirrored, swapping axes for 90/270 or reversing floor/ceil for 180 or mirroring. *naming: transform-inversion:applied/ignored, reorient-by-transform, transform-reorients
        requireAxisAlignmentment - true/false - round-if-axis-aligned? only apply the rounding when it is axis aligned, including straight lines (horizontal/vertical) and bezier nodes with straight handles.
        directionInverts - true/false - the line direction reverses interpretation. e.g. floor(x) is treated as ceil(x) for a line going up (negative) vs down (positive). Otherwise ceil is ceil, floor is floor. *naming: invert-by-direction?
        windingInverts - true/false - treat direction-inverted so that lines going down as reverse interpretation. Unclosed paths or polylines are treated as if closed. Note the original path winding in design space is used (not the path winding after world transformation, which flips when mirrored).
            [name?] windingAffect=invert/none directionAffect=invert/none axisAlignmentment=required or axisAffect=alignedOnly or orthogonality=required
        proportionalShear - "tangent"? adjust the axis proportional to the displacement of the other axis, following the contour of the vertex. e.g. Consider the letter A's T-junction on the horizontal bar, where aligning y vertically to a whole pixel without also adjusting x would distort the shape and give an awkwardly thin/thick stem near that T junction. proportion(0.2 1)
            proportion(1 0 0 1) - multiply the final deltas with an additional proportional bias. naming: delta-shear? displacement-scale? delta-multiplier?
            ?proportional is essentially a form of postbias (or maybe it literally is the m12 and m21 fields of the postbias transform).
                it's useful for a pair of open scissors (icons8-fluency-cut.svg) or the tab of a manilla folder or cube (icons8-fluency-cube.svg) where pure rounding would distort the 45-degree line shape.
                Useful for gears so the angled sprockets are extended as much as the top and bottom sprockets (icons8-color-settings.svg).
                scale-displacement?
                useful for icons8-fluency-windows-calendar.svg to ensure dots are even spaced apart, so the outer dots are spaced as much as the distance between the inner dots.
            ?round proportionally based on adjacent line segment angle rather explicit proportion keyword which would require a different value per each point and be far more tedious?
        additive? - add the delta to the coordinate rather rounding the coordinate and delta together. So x = x + round(delta) rather than x = round(delta + x). todo: Is there a better name? Both cases are additive, but one is outside the rounding. roundDeltaOnly? unroundedCoordinate?
        position based on object size? e.g. anchor-position="0% 100%" for left top. Or maybe anchor-points="0,0 40,0 40,20" to directly use an implicit anchor.
        scaleDelta/deltaScale - subset of proportional scale that applies only to the current delta. e.g. scaleDelta(2 3) scales x by 2 and y by 3.
            How to scale x coordinate by an anchor? The typewriter keys in icons8-blog.svg could use this to space all the keys equidistantly.
        shearDelta/deltaShear -  subset of proportional shear that applies only to the current delta. e.g. shearDelta(0.25 0) adjusts x by 1/4 of y delta, and leaves y alone.
        displace/projectPpu/ceilPpu - (axis=xy round=ceil size=1 bias=0 fraction=0.5 minimum=0 scale/multiple=1); x += (max(ceil(ppu*size + bias, multiple), minimum) - ppu*size) * fraction. 0.5 fraction can be used to apply half expansion on either side of a path line.
            nudge perpendicular to strokes based on ppu (grid size agnostic) to widen or narrow a path to whole pixels. Can apply 0.5 fraction to adjust half on either side of a path.
            A scale/multiple can round stems to even widths. e.g. icons8-fluency-right.svg Otherwise they will remain blurry, unless combined with a vertical adjustment.
        Should anchor-rounding be a separate attribute in that case to avoid points also being rounded?
        ?round only if at least a given ppu? can this be achieve via anchors with ppu-range?
            - adjust using another adjustment with optional scale, shear, and displacement factors. Useful for symmetric adjustments, such as radial symmetry of a gear or mirror symmetry.
        adjustUsing - adjust the current position by some pixel delta or an anchor.
            adjustUsing(#anchorname xscale yscale xshear=0 yshear=0) or standard matrix form [sx hy hx sy dx dy]?
            adjustUsing(#existingAdjustment sx=1 hx=0 sy=1 hy=0 dx=0 dy=0)
            adjustUsing(#existingAdjustment matrix=[sx hx sy hy dx dy])
            Useful for gear sprockets to keep the same angle for the diagonals as the top and bottom sprockets (icons8-color-settings.svg).
    aliases:
        leftward - snap to nearest pixel integer coordinate left from x, if not already perfectly aligned. Equals floor(x). naming: leftward? west? roundLeft? "left" is already used in SVG transform-origin to mean the left *side* rather than leftward as a direction. So use leftward to distinguish.
        rightward - snap to nearest pixel integer coordinate right from x, if not already perfectly aligned. Equals ceil(x). naming: rightward? east? roundRight?
        upward - snap to nearest pixel integer coordinate up from y, if not already perfectly aligned. Equals floor(y).
        downward - snap to nearest pixel integer coordinate down from y, if not already perfectly aligned. Equals ceil(x).
        nearestTiesLow - round to nearest integer with ties down, not banker's rounding which would yield uneven appearance. Equals nearestLeft and nearestUp.
        nearestTiesHigh - round to nearest integer with ties down, not banker's rounding which would yield uneven appearance. Equals nearestLeft and nearestUp.
        nearestLeftward - snap to nearest pixel coordinate left from x and up from y (if not already perfectly aligned). Equals `ceil(x-.5)`.
        nearestRightward - Equals `floor(x+.5)`.
        nearestUpward - ...
        nearestDownward - ...
        nearestDiagonalHalf - snap to pixel corners or pixel centers on both axes. Equivalent to: prebias(1 1 -1 1 0.5 0.5) floor postbias(0.5 -0.5 0.5 0.5 -0.5 -0.5).
        rotateCcw45SqrtTwo - Equivalent to: prebias(1 1 -1 1 0.5 0.5)
        rotateCw45InverseSqrtTwo - Equivalent to: postbias(0.5 -0.5 0.5 0.5 -0.5 -0.5).
        todo: should "nearest" name be avoided because Nearest may also mean rounded away from zero? halvesUp? fractionUp? "Halves up would be confusing with existing rounding nomenclature because geometric "up" is actually numerically "down". Then, certain bonkers programming languages refer to UP meaning away from zero and DOWN meaning toward zero regardless of sign (https://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html, https://docs.python.org/3/library/decimal.html#rounding-modes).
        center - snap to pixel center. Ties default to left and up. Equals `ceil(x-.5)+.5`. Equivalent to `ceil(xy -0.5 1 0.5)`. [naming] Could this be confused with the center of the shape, especially given adjustCenter()?
        centerLeftward - snap to nearest pixel center to the left from the x coordinate (if not already perfectly aligned)
        centerRightward
        centerUpward
        centerDownward
        edgeLeftward - round to pixel edge (not center)
        edgeRightward
        edgeUpward
        edgeDownward
        expand - displace the point outward. alias for "displace(xy mode=ceil directionInverts=true windingInverts=true)".
            TODO: Would the expansion only work for orthogonal rounding? How about displacing along 45 angles?
            Maybe instead use "displace(xy mode=ceil multiple=1 directionInverts=false windingInverts=false vector=normal)"
        contract - displace the point inward. alias for "displace(xy mode=floor directionInverts=true windingInverts=true)".
        expandHalf = expand with fraction=0.5
        contractHalf = contract with fraction=0.5
        centerTieLow - round toward lower coordinates (up/left).
        centerTieHigh - round toward higher coordinates (down/right).
        nearestCenterLeftward - or centerTieLeftward
        nearestCenterRightward - or centerTieRightward
        nearestCenterUpward - or centerTieUpward
        nearestCenterDownward - or centerTieDownward
        nearestUpward - preferring this one
        inward - snap pixel inward (equivalent to outward on counterClockwise shape). e.g. alias for "floor(directionInverts=true windingInverts=true)"
        inwardCw - snap pixel inward if clockwise winding (outward on counterClockwise shape). "floor(directionInverts=true windingInverts=false)"
        outward - ... alias for "directionInverts(true) windingInverts(true) ceil(x) floor(y)" or "round(axes=xy mode=[ceil floor] directionInverts=true windingInverts=true)"
        outwardCw - ... snap pixel outward if clockwise winding or inward on counterClockwise shape. Alias for "round(axes=xy mode=[ceil floor] directionInverts=true windingInverts=false)"
        inwardCwCenter - ...
        inwardCcwCenter - ...
        outwardCwCenter - ...
        outwardCcwCenter - ...
        inwardCwNearestCenter - ...
        inwardCcwNearestCenter - ...
        outwardCwNearestCenter - ...
        outwardCcwNearestCenter - ...
        evenHigh/Low - round to nearest even number
        oddHigh/Low - round to nearest odd number
        evenNearestLow - round to nearest even number
        oddNearestLow - round to nearest odd number
        evenOddLow - Round to pixel edge if even or pixel center if odd ppu. e.g. `evenodd(2)` (ppu-scale bias minimum)
        evenOddHigh
        evenOddLeftward
        evenOddRightward
        evenOddUpward
        evenOddDownward
        oddShift?
        parityShift?
        nearest edge shift? When stems could be closer to the left edge or right edge, choose whichever edge is closer. Maybe a subclass of parity-shift, customizable by accepting numeric parameters?
        adjustPoint - adjustPoint(x:# y:# rounding:$). e.g. adjustPoint(left top nearest)  OR  adjustPoint(x:0% y:0% rounding:nearest)
        adjustCorners(nearest) - ...
        adjustLeftTop(nearest) - ...
        adjustCenter(nearest) - ...
        adjustWidth(nearest) - valid in shapeAdjust for any object that has width (e.g. rect, image, pattern).
        adjustHeight(nearest) - valid in shapeAdjust for any object that has height (e.g. rect, image, pattern).
        adjustLinear(0 50 100 50 nearest) - adjust(type:linear points=[# # # #] rounding:$)
        vectorRound - round along given vector. e.g. vector-round(axes=xy mode=floor/ceil scale=1 bias=0 vector=[1 1]) todo: minimal 2D vector via 2 scalars or full vector 4 scalars? [1 1 -1 1]
            Consider an octagon where the top left line might need to move orthogonal to the 45-degree line rather than along x and y axes.
            This can probably just be part of uberround using a matrix or vector attribute.
        vectorFloor - round along given vector? vector-floor(1 1 -1 1 0.5 0.5 0.5 0.5) scale factors x 4, prebias x y, postbias x y. Can this be simplified by using a vector in floor? Seems redundant, but maybe it is the most complete form while not allowing full matrix transforms. Inverse is computed as det = a*d - b*c. 2D inverse = [d -b; -c a] / det.
        vectorCeil - inverse of vector-floor. Tis technically redundant since can flip the scale sign (e.g. ceil = -scale * floor(x / -scale) = -floor(-x)).
    interactions
        calc() https://drafts.csswg.org/css-values-4/#funcdef-calc and var() https://www.w3.org/TR/css-variables-1/#variables-in-shorthands are not supported inside grid rounding. This should be compatible with SVG Native which doesn't support them anyway, but all parsers must skip unknown identifers and the following content within parentheses to allow for future calls.
        axis alignment and direction inversion uses the resolved effective transform rather than the raw world transform, thus considering any active vector-effect: non-scaling-size, non-rotation, fixed-position (2022-04-19 https://svgwg.org/svg2-draft/coords.html#VectorEffectProperty)
        shape-rendering crispEdges is not affected https://www.w3.org/TR/SVG11/painting.html#ShapeRenderingProperty
        stroke-alignment (https://www.w3.org/TR/svg-strokes/#SpecifyingStrokeAlignment) and outline projection are independent. Imo Gavin Kistner's stroke-alignment is currently insufficiently defined, as inner and outer are ambiguous in too many cases, but it's a step forward. There should also be a 'left' and 'right' side enum, depending on the stroke direction. Clipping and masks are another way to achieve them: https://alexwlchan.net/2021/03/inner-outer-strokes-svg/.
        vector effects (https://dev.w3.org/SVG/modules/vectoreffects/master/SVGVectorEffectsPrimer.html) apply to the individual shapes, not the result.
        filter effects should support rounding adjustment. e.g. feDropShadow has deltaAdjust to round dx and dy to whole pixels. feImage supports transformAdjust to snap images to tile whole pixels, which avoids Moire patterns.
    questions:
        How to snap diagonal lines, to either pixel centers or corners, but not midpoints between pixel centers? e.g. D:\src\Pikselai\resources\icons\icons8\icons8-color-close.svg
        ?How does vector-effect="non-scaling-stroke" interact?
        When fitting to two anchors, where one of the other anchors was also displaced by an anchor, is the displacement just the final grid rounding delta or the whole delta from the original ideal coordinate in world space?
        should text elements (https://developer.mozilla.org/en-US/docs/Web/SVG/Element/text) have bounds that encompass the whole text (from ascenders to descenders) or just the baseline (single horizontal line). Aligning the baseline is more important than the top and bottom.
    Rounding outward diagram:
        out clockwise:

                   y-floor
                ------------->
                /\    +      |
                |            |
        x-floor |-          +| x-ceil
                |            |
                |     -     \/
                <-------------
                    y-ceil


        out anticlockwise:

                   y-floor
                <-------------
                |     -     /\
                |            |
        x-floor |+          -| x-ceil
                |            |
                \/    +      |
                ------------->
                    y-ceil

Example:
    Grid alignment can be part of the existing transform="..." attribute, because browsers (Chrome and Edge anyway) ignore the remainder of the transforms upon seeing any unrecognized calls.
        e.g. transform="scale(3) grid-align(plusSignCenter) translate(13 24)"
        Chrome ignores scale and translate. LunaSvg respects everything before the unrecognized token, meaning scale but not translate.
        So (short of changing browser behavior) it must be a separate attribute, like transform-adjust.
        Additionally it should be distinct from "transform" to reside in its own namespace.
        Additionally fine adjustments/grid alignment need to be relative to the actual device pixel space, whereas transform is relative to user coordinate space.

        <!-- icons8-fluency-add-ot-clipboard-4-sizes.svg -->
        <anchor id="plusSignTopLeftCorner" x="37.5" y="37.5" grid:rounding="up left" />
        <g grid:align="plusSignTopLeftCorner">
            <anchor id="plusSignCenter" x="38" y="38" grid:rounding="edgeTieLow" grid:multiple="0.5"/><!-- round to nearest half pixel -->
            <g grid:adjust="plusSignCenter">
                <circle cx="38" cy="38" r="10"/>
                <path d="m 38.5,43 h -1 C 37.224,43 37,42.776 37,42.5 v -9 C 37,33.224 37.224,33 37.5,33 h 1 c 0.276,0 0.5,0.224 0.5,0.5 v 9 c 0,0.276 -0.224,0.5 -0.5,0.5 z" fill="#FFFFFF">
                <path d="m 33,38.5 v -1 C 33,37.224 33.224,37 33.5,37 h 9 c 0.276,0 0.5,0.224 0.5,0.5 v 1 c 0,0.276 -0.224,0.5 -0.5,0.5 h -9 C 33.224,39 33,38.776 33,38.5 z" fill="#FFFFFF">

                ...
                <!-- 3 anchors are used in the path for displacement.
                     Multiple anchors can apply to multiple points,
                     such as leftPart (#0) and anotherPart (#2) applying to the last point. -->
                <path grid:adjustment-list="leftPart rightPart anotherPart" d="m 10 10 h20 v20 z" grid:d="ga0 m 10 10 ga1 h20 ga0 2 v20 z"/>
            </g>
        </g>

        Newer syntax:
        <!-- icons8-fluency-add-ot-clipboard-4-sizes.svg -->
        <anchor id="plusSignTopLeftCorner" x="37.5" y="37.5" ps:point-adjust="upward leftward" />
        <g ps:transform-adjust="#plusSignTopLeftCorner">
            <anchor id="plusSignCenter" x="38" y="38" ps:rounding="edgeTieLow(multiple=0.5)"/><!-- round to nearest half pixel -->
            <g ps:transform-adjust="#plusSignCenter">
                <circle cx="38" cy="38" r="10"/>
                <path d="m 38.5,43 h -1 C 37.224,43 37,42.776 37,42.5 v -9 C 37,33.224 37.224,33 37.5,33 h 1 c 0.276,0 0.5,0.224 0.5,0.5 v 9 c 0,0.276 -0.224,0.5 -0.5,0.5 z" fill="#FFFFFF">
                <path d="m 33,38.5 v -1 C 33,37.224 33.224,37 33.5,37 h 9 c 0.276,0 0.5,0.224 0.5,0.5 v 1 c 0,0.276 -0.224,0.5 -0.5,0.5 h -9 C 33.224,39 33,38.776 33,38.5 z" fill="#FFFFFF">

                ...
                <!-- 3 anchors are used in the path for displacement.
                     Multiple anchors can apply to multiple points,
                     such as leftPart (#0) and anotherPart (#2) applying to the last point. -->
                <path ps:adjustment-list="#leftPart #rightPart #anotherPart" d="m 10 10 h20 v20 z" ps:d="ga0 m 10 10 ga1 h20 ga0 2 v20 z"/>
            </g>
        </g>

        <svg xmlns="http://www.w3.org/2000/svg" xmlns:ps="https://github.com/fdwr/LunaSvgSampleTest">
          ...
          <grid:anchor id="plusSignCenter" x="38" y="38" grid:rounding="upward leftward" />
          ...
          <g grid:adjust="plusSignCenter">
            <circle cx="38" cy="38" r="10"/>
            <path d="m 38.5,43 h -1 C 37.224,43 37,42.776 37,42.5 v -9 C 37,33.224 37.224,33 37.5,33 h 1 c 0.276,0 0.5,0.224 0.5,0.5 v 9 c 0,0.276 -0.224,0.5 -0.5,0.5 z" fill="#FFFFFF">
            <path d="m 33,38.5 v -1 C 33,37.224 33.224,37 33.5,37 h 9 c 0.276,0 0.5,0.224 0.5,0.5 v 1 c 0,0.276 -0.224,0.5 -0.5,0.5 h -9 C 33.224,39 33,38.776 33,38.5 z" fill="#FFFFFF">
          </g>
          ...
          <switch>
            <g grid:ppu-range="0 16">
              <!-- less detailed version for less than 16 pixels per unit... -->
            </g>
            <g grid:ppu-range="16">
              <!-- tiny details visible at higher ppu, at least 16 PPU... -->
            </g>
          </switch>
        </svg>

    One anchor can be defined relative to another one.
    Below, the bottom component is kept at least 1 pixel away from the top component so there is separation between them.
        <anchor x="20" y="30" grid-minimum-distance="otherAnchor 1 0; secondAnchor 0 -1"/>
    todo: second anchor is relative to the first anchor's rounded screen location rather than user coordinates.
    todo: what if you want *exactly* 1 device pixel regardless of size, not just a minimum? round up combined with minimum?
    todo: what about 45 degree angles, so that two octagons keep the same distance from each other? It's okay if the corners
    todo: should origin be the final device pixels or the user coordinates? rounding to nearest half pixel would be useful, e.g. grid-origin="0.5px 0.5px"
          are antialiased if the straight lines are snapped, and probably more important they have the same relative thickness.
          A grid-rounding attribute like "tangential" or "linear" or "fromOrigin" or "alongOriginAxis"...?
    todo: can you have relative inline anchors, such as <rect ...><anchor position="0% 0%" grid-rounding="up"/></rect> which is positioned at the left top of the rect.
          How do you align to it though? Does it need an id, just for that one case, which kinda defeats the convenience factor?
          Or <rect ... anchor-points="0% 100%" anchor-rounding="up" grid-rounding="out"/></rect> ?
          Percentages are similar in concept to primitiveUnits="objectBoundingBox" which make the lengths relative to the referencing object's bounding box https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/primitiveUnits
          Anchor frame percentages in <defs> could be treated as userSpaceOnUse or objectBoundingBox? Rather than gradientUnits or patternUnits, have anchorUnits.

        <anchor id="topComponentBottomAnchor" y="40" grid-rounding="nearest">
        <anchor id="bottomComponentTopAnchor" y="41" grid-rounding="down" grid-origin="topComponentBottomAnchor"><!-- ensure at least one pixel away -->
        <path id="topComponent" anchor-list="topComponentBottomAnchor" d="an m0 0 h80 an0 v40 h-80 z"/><!-- first "an" sets to no anchors, second "an" sets anchor #0 -->
        <path id="bottomComponent" anchor-list="bottomComponentTopAnchor" d="an0 m0 41 h80 an v40 h-80 z"/><!-- first "an" sets anchor, second "an" resets to no anchors -->

    You can supply a scale and bias directly in the rounding mode. floor((x-bias)/multiple)*multiple+bias

        <g grid-rounding="floor-x(1 0.5)"><!-- round down to pixel centers -->
        <g grid-rounding="floor-x(2 0.0)"><!-- scale grid by 2x -->
        <g grid-rounding="floor-x(2 -0.5 0.5)"><!-- scale grid by 2x and round to 0.5's, where 0 to 2.49 yield 0.5, 2.5 to 4.49 yield 2.5. Formula = floor((x-.5)/2)*2+.5 -->
        <g grid-rounding="floor-x(0.5)"><!-- round to every half a pixel -->

        <g grid-rounding="x floor prebias(0.5)"><!-- round down to pixel centers -->
        <g grid-rounding="x floor scale(2)"><!-- scale grid by 2x -->
        <g grid-rounding="x floor scale(2) prebias(-0.5) postbias(0.5)"><!-- scale grid by 2x and round to 0.5's, where 0 to 2.49 yield 0.5, 2.5 to 4.49 yield 2.5. Formula = floor((x-.5)/2)*2+.5 -->
        <g grid-rounding="x floor scale(0.5)"><!-- round to every half a pixel -->

        <g grid-rounding="floor(x 1 0.5)"><!-- round down to pixel centers -->
        <g grid-rounding="floor(x 2 0.0)"><!-- scale grid by 2x to round to multiples of 2 -->
        <g grid-rounding="floor(x 2 -0.5 0.5)"><!-- scale grid by 2x and round to 0.5's, where 0 to 2.49 yield 0.5, 2.5 to 4.49 yield 2.5. Formula = floor((x-.5)/2)*2+.5 -->
        <g grid-rounding="floor(x 0.5)"><!-- round to every half a pixel -->

        <g grid-rounding="floor(x bias=0.5 multiple=1)"><!-- round down to pixel centers -->
        <g grid-rounding="floor(x bias=0.0 multiple=2)"><!-- scale grid by 2x -->
        <g grid-rounding="floor(x prebias=0.5 postbias=0.5 multiple=2)"><!-- scale grid by 2x and round to 0.5's, where 0 to 2.49 yield 0.5, 2.5 to 4.49 yield 2.5. Formula = floor((x-.5)/2)*2+.5 -->
        <g grid-rounding="floor(x bias=0.5)"><!-- round to every half a pixel -->

    Referring to the same anchor twice in a nested group will be a nop, since the outer group
    already aligned the anchor. (but how to achieve this? how to know the outer one applied?)
    Naming "adjust" would make this clearer, or be less surprising at least.

        <anchor id="plusSignTopLeftCorner" x="37.5" y="37.5" grid-rounding="up left">
        <g grid-align="plusSignTopLeftCorner">
            <g grid-align="plusSignTopLeftCorner"><!-- nop since already pixel aligned -->
                <path d="m 10 10 h20 v20 z"/>
            </g>
        </g>

    You should be able to stretch components too between the bounds, which translates to a tranform scale and translate:

        <anchor id="topLeftCorner" x="40" y="40" grid-rounding="up left">
        <anchor id="bottomRightCorner" x="60" y="60" grid-rounding="down right">
        <g grid-fit="topLeftCorner bottomRightCorner">
            <circle cx="50" cy="50" r="10"/>
        </g>

        More concise:
        <g adjust="bounds outward">  OR  align="bounds outward"
            <circle cx="50" cy="50" r="10"/>
        </g>

    Inline notation?

        <rect anchor="top" transform-adjust="upward"/>
        <rect transform-adjust="top upward"/>
        <rect transform-adjust="anchor(top upward)"/>
        <rect transform-adjust="bounds upward"/> // round top and bottom upward
        <rect transform-adjust="round-edges-upward"/> // round top and bottom upward (bounds are implicit if not given)

    Center in position vs rounding ambiguity?

        <rect transform-adjust="center round-upward"/> // rounds the center upward to a pixel edge
        <rect transform-adjust="round-center-upward"/> // rounds the bounds to a pixel center. round-half-upward?

    You should be able to stretch along vertical or horizontal and retain the aspect ratio for the other:

        <g transform-adjust="bounds-horizontal outward top upward">  VS  width-retain-ratio  VS  width-uniform
            <circle cx="50" cy="50" r="10"/>
        </g>

    You should be able to define an anchor frame comprised of other existing anchors:
    
        <anchor id="anchorA" x="40" y="40" grid-rounding="up left"/>
        <anchor id="anchorB" x="60" y="40" grid-rounding="up right"/>
        <anchor id="anchorC" x="60" y="60" grid-rounding="down left"/>
        <anchor id="anchorD" x="40" y="60" grid-rounding="up left"/>
        ...
        <anchor-set id="anchorSetA" anchor-list="anchorA anchorB anchorC"/>
        <anchor-set id="anchorSetB" anchor-list="anchorA anchorD anchorC"/>

    Or via containment? (id's on internal anchors are then unnecessary):
    
        <anchor-set id="anchorSetA">
            <anchor x="40" y="40" grid-rounding="up left"/>
            <anchor x="60" y="40" grid-rounding="up right"/>
            <anchor x="40" y="60" grid-rounding="down left"/>
        </anchor-set>

    Or via points? (which would allow in/out rounding modes)

        <anchor-set id="anchorSetA" points="40,40 60,40 60,60 40,60" grid-rounding="out"/>
        <anchor-set id="anchorSetA" anchors="40,40 60,40 60,60 40,60" grid-rounding="out"/>

    Or should there just be <anchor>, not anchor-set, except it accepts multiple existing ones?

        <anchor id="anchorSetA" anchor-list="anchorA anchorB anchorC"/>

    Or mix of both?

        <anchor-set id="anchorSetA" anchors="42,36 anchorB 0%,50% left,top"/>

    Or points and rounding?

        <anchor-set id="anchorSetA" anchors="42,36 up left anchorB 0%,50% down left west,north"/>

    Anchor sets may only take "anchors" or "points" attributes or child anchor elements, but not more than one.
    An anchors attribute is preferred over points, and points over child elements.

    Can anchors have multiple points? e.g. <anchor points="40,60 40,40 60,60" grid-rounding="down left"/>
    Or should anchors only ever be 1D points? And only anchor sets allow "points" attributes?
    It would be more concise to allow anchor with "points" and often mean only one primitive to think about <anchor>.
    Though it would be confusing if anchor allowed multiple points because when an anchor set then references an anchor, what does that mean?

    grid-fit should accept 1, 2, or 3 anchors for points, which is translation, scaling along x and y, or arbitrary scaling/rotation/shear.
    1 point is equivalent to 3 points repeating the same value.
    2 points is equivalent to 3 points with the 3rd point holding an x and y value from the other 2 points. Or 4 points making a square?
    If more than 3 points are provided, only 3 points are used to extract the affine transformation, as non-affine transforms are unsupported by most 2D renderers.

    Rotation should reinterpret rounding modes, so that the final bitmap looks identical when rotated in-place as it would if it was
    graphically rotated. There are however times where disabling that reinterpretation is useful, such as when rotating a petal
    around a flower or mirroring slats of a fence, where having consistent rounding across mirrored segments looks better.
    Attribute grid-rounding: subattribute transform-matters

    Inline anchors Would a be convenient shorthand rather than needing a separate anchor each time with a unique id.
    Instead of:

        <anchor id="RectAnchor" x="23" y="42" grid-point-rounding="upward leftward"/>
        <rect x1="23" y1="42" width="20" height="10" grid-align="RectAnchor"/>

    Just say:
        <rect x1="23" y1="42" width="20" height="10" grid-align="anchor(23 42 up left)"/>
        <rect x1="23" y1="42" width="20" height="10" grid-align="0%,0% 100%,100% up left)"/>
        <rect x1="23" y1="42" width="20" height="10" grid-align="bounds round-out)"/>
        <rect x1="23" y1="42" width="20" height="10" grid-align="points(0%,0% 100%,100%) rounding(up left))"/>

    Note aligning a single anchor point is different from aligning all the points individually, which would change the height/width:
        <rect x1="23" y1="42" width="20" height="10" grid-point-rounding="up left"/>

    Or maybe:
        <rect x1="23" y1="42" width="20" height="10" grid-points="0%,0% 100%,100%" anchor-rounding="up left"/>
        <rect x1="23" y1="42" width="20" height="10" grid-points="0%,0%" anchor-rounding="up left"/> // translate by rounded top left

    Or concise:
        <rect x1="23" y1="42" width="20" height="10" adjust="left top" adjustment-rounding="leftward upward"/> // translate by rounded top left
        <rect x1="23" y1="42" width="20" height="10" adjust="left top leftward upward"/> // translate by rounded top left
        <rect x1="23" y1="42" width="20" height="10" adjust="left top leftward upward right bottom rightward downward"/> // stretch corners out
        <rect x1="23" y1="42" width="20" height="10" adjust="left top floor right bottom ceil"/> // stretch corners out
        <rect x1="23" y1="42" width="20" height="10" adjust="bounds out"/> // round boundary outward
        <rect x1="23" y1="42" width="20" height="10" adjust="#outerFrame out"/> // round boundary outward

    Minimum stroke:
        <circle cx="50" cy="50" r="10" stroke="#70F800" stroke-width="3" grid-minimum-stroke-width="1px"/>

    Pixel aligned stroke width (e.g. rounded to nearest whole pixel):
        <circle cx="50" cy="50" r="10" stroke="#70F800" stroke-width="3" grid-stroke-width-rounding="ceil" grid-stroke-width-bias="0.5"/>
        <circle cx="50" cy="50" r="10" stroke="#70F800" stroke-width="3" stroke-width-rounding="round(mode=ceil bias=0.5 minimum=1)"/>

    Maybe declare different kinds of alignments/anchors, like linearGradient vs radialGradient:

        <pointAlignment id="foo" x="1" y="1" rounding="floor" />
        <linearAlignment id="foo" x1="1" x2="2" y1="3" y2="4" adjustment1="floor" adjustment2="ceil" />
        <linearAlignment id="foo" x1="1" x2="2" y1="3" y2="4" adjustment="floor; ceil" />
        <linearAlignment id="foo" x1="1" x2="2" y1="3" y2="4" adjustment="out" />
        <twoCornerAlignment id="foo" x1="1" x2="2" y3="3" y2="4" adjustment="floor; ceil" />
        <threePointAlignment id="foo" points="1 1 2 2 3 3" adjustment="floor; ceil; floor" />

        <alignment mode="point" id="foo" points="1 1" rounding="floor" />
        <alignment mode="linear" id="foo" points="1 1; 2 2" adjustment1="floor" adjustment2="ceil" />
        <alignment mode="linear" id="foo" points="1 1; 2 2" adjustment="floor; ceil" />
        <alignment mode="linear" id="foo" points="1 1; 2 2" adjustment="out" />
        <alignment mode="twoCorner" id="foo" points="1 1; 2 2" adjustment="floor; ceil" />
        <alignment mode="threePoint" id="foo" points="1 1; 2 2; 3 3" adjustment="floor; ceil; floor" />
        <alignment mode="quad" id="foo" points="0 0; 0 1; 1 1; 1 0" adjustment="leftward upward; rightward upward; rightward downward; leftward downward" />
        <alignment mode="quad" id="foo" points="0 0; 0 1; 1 1; 1 0" adjustment="outward" />

        boundsAdjust="align(x=50% y=20 rounding=#adjustment) fit-proportional(x1=0 x2=1 y1=2 y2=3 rounding=#adjustments)"
        cornerAdjust="align(x=50% y=20 rounding=#adjustment) fit-proportional(x1=0 x2=1 y1=2 y2=3 rounding=#adjustments)"
        pointAdjust="align(x=50% y=20 rounding=#adjustment) fit-proportional(x1=0 x2=1 y1=2 y2=3 rounding=#adjustments)"

        adjustBounds="align(x=50% y=20 rounding=#adjustment) fit-proportional(x1=0 x2=1 y1=2 y2=3 rounding=#adjustments)"
        adjustCorners="align(x=50% y=20 rounding=#adjustment) fit-proportional(x1=0 x2=1 y1=2 y2=3 rounding=#adjustments)"
        adjustPoints="align(x=50% y=20 rounding=#adjustment) fit-proportional(x1=0 x2=1 y1=2 y2=3 rounding=#adjustments)"

    Can anchors be parameterized when using use?

        <svg>
          <defs>
            <circle id="myCircle" cx="0" cy="0" r="5" adjust="#circleAnchor"/>
          </defs>
          <adjustment id="firstAnchor" .../>
          <adjustment id="secondAnchor" .../>
          <use href="#myCircle" x="10" y="10" fill="blue" params="circleAnchor=firstAnchor"/>
          ...
          <use href="#myCircle" x="10" y="10" fill="blue" params="circleAnchor=secondAnchor"/>
        </svg>

    There's already a CSS proposal:

        https://www.w3.org/TR/SVGParamPrimer/
        https://dev.w3.org/SVG/modules/ref/master/SVGRefPrimer.html

        <use href="...">
            <param name="base" value="brown" />
            <param name="background" value="red" />
        </use>

        CSS variables ridiculously goofy. So, avoid them. https://drafts.csswg.org/css-variables-1/#funcdef-var
        var(--foobar)

    Using the art picture frame:

        <!-- booth.pm assets arts 144-4b309d4dce8b848ec7713199ba3b782ec1915a1550f7efd179de4332d54040bd.svg -->
        <svg ...>
            <!-- top left outer, top left inner -->
            <anchor x="2"  y="10" id="clipboardTLO" grid-round="up left">
            <anchor x="8"  y="16" id="clipboardTLI" grid-align="clipboardTLO" grid-round="down right">
            <anchor x="38" y="10" id="clipboardBLO" grid-round="down left">
            <anchor x="32" y="16" id="clipboardBLI" grid-align="clipboardBLO" grid-round="up right">
            <anchor x="2"  y="38" id="clipboardTRO" grid-round="up right">
            <anchor x="8"  y="32" id="clipboardTRI" grid-align="clipboardTRO" grid-round="down left">
            <anchor x="38" y="38" id="clipboardBRO" grid-round="down right">
            <anchor x="32" y="32" id="clipboardBRI" grid-align="clipboardBRO" grid-round="up left">

            <!-- alternately use the edges instead -->
            <anchor y="10" id="clipboardTopOuter"    grid-round="up">
            <anchor y="16" id="clipboardTopInner"    grid-align="clipboardTopOuter" grid-round="down">
            <anchor y="38" id="clipboardBottomOuter" grid-round="down">
            <anchor y="32" id="clipboardBottomInner" grid-align="clipboardBottomOuter" grid-round="up">
            <anchor x="2"  id="clipboardLeftOuter"   grid-round="left">
            <anchor x="8"  id="clipboardLeftInner"   grid-align="clipboardLeftOuter" grid-round="right">
            <anchor x="38" id="clipboardRightOuter"  grid-round="left">
            <anchor x="32" id="clipboardRightInner"  grid-align="clipboardRightOuter" grid-round="right">

            <!-- starting from top right corner of picture frame, use top outer and right outer, then preceeding counter-clockwise use just top outer, then top and right... -->
            <path
                anchor-list="clipboardTopOuter clipboardTopInner clipboardBottomOuter clipboardBottomInner clipboardLeftOuter clipboardLeftInner clipboardRightOuter clipboardRightInner"
                d="ga 0 6 M 38,11 C 38 10.9 38 10.7 37.9 10.6 .. ga 0 H 33.3 L 22.8 2.8 C 21.1 1.6 18.8 1.6 17.1 2.8 ... g 0 2"
            />

            <!--
                Can you pass anchors to rect/circle/ellipse?
                If so, should they be relative to the corners or the edges?
                If using corners, what does it mean to pass 4 anchors if the 4th point would create a trapezoid?
                Edges may be cleaner?
                Maybe there should be no "anchors" and only a "grid-fit" (or "grid-align"/"grid-adjust").
                Can you use "none" as a placeholder in the list if you want no changes?
            -->
            <anchor x="20" y="20" id="boxTopLeft" grid-round="nearest-edge-low">
            <anchor x="38" y="38" id="circleCenter" grid-round="round-even-odd-low(xy 20)">

            <rect x="20" y="20" width="10" height="10" anchor-list="#boxTopLeft #boxTopRight #boxBottomLeft #boxBottomRight"/>
            <circle cx="38" cy="38" r="10" anchor-list="#circleCenter #circleTopLeft #circleTopRight #circleBottomLeft #circleBottomRight"/>
        </svg>

    Separate anchors by a minimum distance:

        minimumDistance(#leftTop distance=[1 0])
        minimumDistance(#rightTop distance=[-1 0])
        minimumDistance(#leftTop [1 0])
        minimumDistance(#rightTop [-1 0])
        minimumDistance(#leftTop 1 right)
        minimumDistance(#rightTop 1 left)

        minimumDistance(origin=[50 50] distance=1 vector=[1 0])
        minimumDistance(origin=[50 50] distance=1 transform=rotate(0))
        minimumDistance(origin=[50 50] distance=[1,1] transform=rotate(90))

        <anchor x="2" y="10" id="clipboardTLO" adjust="upward leftward">
        <anchor x="8" y="16" id="clipboardTLI" adjust="#clipboardTLO nearest minimumDistance(#clipboardTLO [1 1])">

        TODO: How to avoid repeating the origin anchor twice? Should there be adjustMinimum that both applies the adjustment and clamps?

        <anchor x="8" y="16" id="clipboardTLI" adjust="adjustMinimumDistance(#clipboardTLO [1 1]) nearest">

        Should be able to clamp stroke widths too, as a single scalar:

        <line strokeWidthAdjust="clamp(2 3)"/>
        <line strokeWidthAdjust="clamp(1)"/>
        <line strokeWidthAdjust="clamp(1.5 indefinite #origin)"/>

    How many different kinds of adjustments are there, and what order do they evaluate? Transform before shape, shape before point?
    Point applies to the final points, including the points on the rounded corners.
    Shape applies to the x, y, w, h corners.
    Transform applies to the ideal bounds and can distort the shape via scale transform.
    Include anchorAdjust for pure anchor adjustments? (that do not affect other objects)

        <rect x="1" y="1" w="4" h="4" rx="1" ry="1" transformAdjust="..." shapeAdjust="..." pointAdjust="..." />

    Aliases for adjustments:
        <rect x="1" y="2" w="3" h="4" shapeAdjust="anchorTransform(type=point points=[0% 0%] rounding=[nearest])" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="anchorTransform(type=twoPointCorner points=[0% 0%; 100% 100%] rounding=[nearest])" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="anchorTransform(type=twoPointCorner points=[0% 0%; 100% 100%] rounding=[floor; ceil])" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="anchorTransform(type=linear points=[0% 50%; 100% 50%] rounding=outward)" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="adjustPoint(50% 50% nearest)" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="adjustTwoCorners(nearest)" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="adjustFourCorners(outward)" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="adjustLeftTop(nearest)" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="adjustRightBottom(nearest)" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="adjustCenter(nearest)" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="adjustWidth(nearest)" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="adjustHeight(nearest)" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="adjustLinear(0% 50% 100% 50% nearest)" />
        <rect x="1" y="2" w="3" h="4" shapeAdjust="adjustBounds(nearest)" />

    Interaction with elements:
        circle cx cy rx ry - rounded how exactly?
        ellipse cx cy rx ry - rounded how exactly?
        line x1 y1 x2 y2 - each point is rounded
        polygon points="0,100 50,25" - each point is rounded
        polyline points="0,100 50,25" - each point is rounded
        rect x y width height rx ry - rounded how exactly?
        path - all points in "d" attribute rounded
        pattern x y width height viewBox - rounded after any patternTransform
        text/textPath x y dx dy - the final pixel position x+dx is rounded, not individually. If you want them separately rounded, wrap it in a <g>.
        use x y - rounded
        image x y width height - rounded
        clipPath - not affected, just subelements (e.g. the circle <clipPath id="someClip"><circle cx="40" cy="35" r="35"/></clipPath>)
        linearGradient - not affected
        radialGradient - not affected

    <switch requiredFeatures="http://www.w3.org/TR/SVG11/feature#GridFitting">
    <switch><g ppu-range="0 2"><g ppu-range="2 10"><g ppu-range="10"></switch>

    For computing ppuc along minimum axis, think of computing the minor axis length along a sheared/rotated ellipse.
        -Possibly use matrix inverse and rotate a point to axis aligned unit vector? [a b; c d] Possibly det = a*d - b*c. 2D inverse = [d -b; -c a] / det.
        -Possibly use eigen vector?
        Use this:
            numpy.set_printoptions(precision=3, floatmode='fixed', suppress=True)
            angle = math.tau * 45 / 360
            r = numpy.array([[cos(angle), -sin(angle)], [sin(angle), cos(angle)]])
            sx = numpy.array([[0.5, 0], [0, 1]])
            sy = numpy.array([[1, 0], [0, 0.5]])
            sxy = numpy.array([[0.5, 0], [0, 0.5]])
            M = R; a = M[0][0]; b = M[0][1]; c = M[1][0]; d = M[1][1]; sqrt(b*b + d*d); sqrt(a*a + c*c)
      Possibly just check x and y after rotating the transform back to axis alignment?
      Unfortunately just transforming 2 unit vectors of axis aligned x and y don't seem robust to all transformations, such as scaling along the diagonal, such as numpy.array([[ 0.707, -0.707], [ 0.354,  0.354]]).

Code snippets
    Determine winding order: https://stackoverflow.com/a/18472899/937938
    Note this won't work with the infinity sign (8) shape.

        double sum = 0.0;
        Vector v1 = vertices[vertices.Count - 1]; // or vertices[^1] with
                                                  // C# 8.0+ and .NET Core
        for (int i = 0; i < vertices.Count; i++) {
            Vector v2 = vertices[i];
            sum += (v2.X - v1.X) * (v2.Y + v1.Y);
            v1 = v2;
        }
        return sum > 0.0;

    https://stackoverflow.com/questions/22954239/given-three-points-compute-affine-transformation

        void AffineSolver(float* AtoF, float* a, float* b)
        {
            AtoF[0] = ( b[1].x * a[0].y - b[2].x * a[0].y - b[0].x * a[1].y + b[2].x * a[1].y + b[0].x * a[2].y - b[1].x * a[2].y) / 
                      ( a[1].x * a[0].y - a[2].x * a[0].y - a[0].x * a[1].y + a[2].x * a[1].y + a[0].x * a[2].y - a[1].x * a[2].y);

            AtoF[1] = ( b[1].x * a[0].x - b[2].x * a[0].x - b[0].x * a[1].x + b[2].x * a[1].x + b[0].x * a[2].x - b[1].x * a[2].x) / 
                      (-a[1].x * a[0].y + a[2].x * a[0].y + a[0].x * a[1].y - a[2].x * a[1].y - a[0].x * a[2].y + a[1].x * a[2].y);

            AtoF[2] = ( b[1].y * a[0].y - b[2].y * a[0].y - b[0].y * a[1].y + b[2].y * a[1].y + b[0].y * a[2].y - b[1].y * a[2].y) / 
                      ( a[1].x * a[0].y - a[2].x * a[0].y - a[0].x * a[1].y + a[2].x * a[1].y + a[0].x * a[2].y - a[1].x * a[2].y);

            AtoF[3] = ( b[1].y * a[0].x - b[2].y * a[0].x - b[0].y * a[1].x + b[2].y * a[1].x + b[0].y * a[2].x - b[1].y * a[2].x) / 
                      (-a[1].x * a[0].y + a[2].x * a[0].y + a[0].x * a[1].y - a[2].x * a[1].y - a[0].x * a[2].y + a[1].x * a[2].y);

            AtoF[4] = ( b[2].x * a[1].x * a[0].y - b[1].x * a[2].x * a[0].y - b[2].x * a[0].x * a[1].y +
                        b[0].x * a[2].x * a[1].y + b[1].x * a[0].x * a[2].y - b[0].x * a[1].x * a[2].y) / 
                      ( a[1].x * a[0].y - a[2].x * a[0].y - a[0].x * a[1].y + a[2].x * a[1].y + a[0].x * a[2].y - a[1].x * a[2].y);

            AtoF[5] = ( b[2].y * a[1].x * a[0].y - b[1].y * a[2].x * a[0].y - b[2].y * a[0].x * a[1].y +
                        b[0].y * a[2].x * a[1].y + b[1].y * a[0].x * a[2].y - b[0].y * a[1].x * a[2].y) / 
                      ( a[1].x * a[0].y - a[2].x * a[0].y - a[0].x * a[1].y + a[2].x * a[1].y + a[0].x * a[2].y - a[1].x * a[2].y);
        }

        https://www.w3.org/TR/SVG11/intro.html#TermConditionalProcessingAttribute

    Matrix transform of point
        https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-xform
        x = m11*x + m21*y + dx
        y = m12*x + m22*y + dy

    d:\src\lunasvgsampletest\external\lunasvg\source\property.cpp

        Transform Transform::operator*(const Transform& transform) const
        {
            double m00 = this->m00 * transform.m00 + this->m10 * transform.m01;
            double m10 = this->m00 * transform.m10 + this->m10 * transform.m11;
            double m01 = this->m01 * transform.m00 + this->m11 * transform.m01;
            double m11 = this->m01 * transform.m10 + this->m11 * transform.m11;
            double m02 = this->m02 * transform.m00 + this->m12 * transform.m01 + transform.m02;
            double m12 = this->m02 * transform.m10 + this->m12 * transform.m11 + transform.m12;

            return Transform{m00, m10, m01, m11, m02, m12};
        }

        Transform Transform::inverted() const
        {
            double det = (this->m00 * this->m11 - this->m10 * this->m01);
            if(det == 0.0)
                return Transform{};

            double inv_det = 1.0 / det;
            double m00 = this->m00 * inv_det;
            double m10 = this->m10 * inv_det;
            double m01 = this->m01 * inv_det;
            double m11 = this->m11 * inv_det;
            double m02 = (this->m01 * this->m12 - this->m11 * this->m02) * inv_det;
            double m12 = (this->m10 * this->m02 - this->m00 * this->m12) * inv_det;

            return Transform{m11, -m10, -m01, m00, m02, m12};
        }

        template <size_t ByteSize>
        struct GetCorrespondingUnsignedIntegerType;
        template<> struct GetCorrespondingUnsignedIntegerType<1> { using Type = uint8_t; };
        template<> struct GetCorrespondingUnsignedIntegerType<2> { using Type = uint16_t; };
        template<> struct GetCorrespondingUnsignedIntegerType<4> { using Type = uint32_t; };
        template<> struct GetCorrespondingUnsignedIntegerType<8> { using Type = uint64_t; };

        template <typename T, typename D = GetCorrespondingUnsignedIntegerType<sizeof(T)>::Type>
        D GetUlpDifference(T a, T b)
        {
            D aBitValue = std::bit_cast<D>(a);
            D bBitValue = std::bit_cast<D>(b);
            return (aBitValue > bBitValue) ?
                   (aBitValue - bBitValue) :
                   (bBitValue - aBitValue); // abs() only accepts signed values
        }

Reference:
    TrueType
        https://docs.microsoft.com/en-us/typography/opentype/spec/tt_instructions#round-to-half-grid
        RTHG - round to half grid
        RTG - round to grid
        RTDG - Round To Double Grid
        RDTG - Round Down To Grid
        RUTG - Round Up To Grid
        ROFF - Round OFF
        SROUND - Super ROUND
        Threshold = prebias
        Phase = postbias
        roundedValue = floor(x - phase - threshold) + phase
    Direct3D 11
        https://microsoft.github.io/DirectX-Specs/d3d/archive/D3D11_3_FunctionalSpec.htm#3.4.2.1%20Top-Left%20Rule
        In graphics triangle rasterization, ties round down (e.g. 1.5->1.0, 2.5->2.0)

Related:
    SVG
        SVG specification - https://github.com/w3c/svgwg/tree/master, https://www.w3.org/TR/SVG2/
        SVG Hinting Proposals - https://www.w3.org/Graphics/SVG/WG/wiki/Proposals/SVG_hinting
        Microsoft W3C rep for SVG - https://github.com/atanassov, https://www.w3.org/groups/wg/svg/participants
        https://svgwg.org/specs/svg-native/
        https://svgwg.org/svg2-draft/conform.html#secure-static-mode
    WPF
        WPF SnapsToDevicePixels and UseLayoutRounding - https://blog.benoitblanchon.fr/wpf-blurry-images/
        WPF GuidelineSets - https://www.wpftutorial.net/DrawOnPhysicalDevicePixels.html
        Images and Icons for Visual Studio - https://docs.microsoft.com/en-us/visualstudio/extensibility/ux-guidelines/images-and-icons-for-visual-studio?view=vs-2022
    TrueType
        TrueType hinting is overkill - https://docs.microsoft.com/en-us/typography/opentype/spec/ttch01
    Tools
        Inkscape SVG editor - https://inkscape.org/
        Cairo based convertor for SVG to PNG - https://cairosvg.org/
        Cairo rendering API - https://cairographics.org/download/
        SVG Path Visualizer webpage - https://svg-path-visualizer.netlify.app/
        SVG Native Viewer - https://github.com/adobe/svg-native-viewer
        CodePen - https://codepen.io/mattdesl/pen/QjMrXV
        Inkscape Plugin PixelSnap - https://code.google.com/archive/p/pixelsnap/
        Sketch Plugin Pixel Perfecter - https://github.com/swiadek/pixel-perfecter-sketch-plugin
        The magnificent 2d matrix - https://ncase.me/matrix/
        Yuri Sulyma's Matrix Visualizer - https://web.ma.utexas.edu/users/ysulyma/matrix/
    Libraries
        parse-svg-path - https://www.npmjs.com/package/parse-svg-path
        normalize-svg-path - https://www.npmjs.com/package/normalize-svg-path
    Guidance
        Material Design "Clarity (Pixel perfection)" - https://material.io/design/iconography/system-icons.html#grid-and-keyline-shapes
        Adobe Spectrum Iconography - https://spectrum.adobe.com/page/iconography/#Characteristics
        Adobe Draw pixel-perfect art https://helpx.adobe.com/illustrator/using/pixel-perfect.html
        IBM Carbon Design System - https://www.carbondesignsystem.com/guidelines/icons/contribute/
        Firefox Photon Design System - https://design.firefox.com/photon/visuals/iconography.html
        Pixel-fitting by Dustin Curtis - https://dcurt.is/pixel-fitting 2012-05-09
        Pushing Pixels About Those Vector Icons by Kirill Grouchnikov - https://www.pushing-pixels.org/2011/11/04/about-those-vector-icons.html 2022-04-25
        Icon Design Vector vs Bitmap by Josh Williams - https://web.archive.org/web/20130209065422/http://www.firewheeldesign.com/sparkplug/2006/April/icon_design_bitmap_vs_vector.php 2022-04-25
        Pixel-snapping in icon design by Helena Zhang - https://uxdesign.cc/pixel-snapping-in-icon-design-a-rendering-test-6ecd5b516522 2022-04-25
        Precision With Every Pixel by Ashley Chang - https://blog.readme.com/precision-with-every-pixel/ 2022-04-25
        The Designer's Guide to Pixel Hinting by Dustin Cartwright *Note he uses the term incorrectly. It's not called "pixel hinting" in this context - https://www.webdesignerdepot.com/2014/03/the-designers-guide-to-pixel-hinting/.  2014-03-17
        My Illustrator snapping settings by Bjango https://bjango.com/articles/illustratorsnapping/  2022-05-22
        The one killer feature icon fonts have over svg OR: why github icons look like shit now https://swatinem.de/blog/the-one-killer-feature-of-icon-fonts/ 2016-01-31
        Pixel Hinting for Crisp Icons by Danelle Bailey http://danellebailey.com/design-blog/2016/9/29/pixel-hinting-for-crisp-icons 2016-10-05
