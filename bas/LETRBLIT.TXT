push ds		;save all necessary variables
push es
push bp
;
mov ax,f000	;ROM Bios segment for letter bitmaps
mov ds,ax
mov ax,a000	;screen base segment
mov es,ax
mov bx,[bp+6]	;get letter (ASCII character code)
mov si,[bx]
mov cl,6
shl si,cl	;multiply by sixty-four by shifting left six
add si,fa6e	;add an ofset of 64110 to get letters base
;----------------------------------
mov bx,[bp+8]	;get row
mov ax,[bx]
test ax,ax	;compare row (ax) over zero using test
jns row_greater_than_zero
 ;===if row less than zero
 sub si,ax	;add row to source
 add ax,8	;subtract row from eight
 xor di,di	;make destination base zero
 jmp row_evaluate
:row_greater
 ;===else row zero or greater
 mov di,140
 mul di		;multiply by 320 to get destination
 neg ax
 add ax,C8	;add 200 to get letter height
 cmp ax,8
 js row_evaluate;height is less than eight if positive (no sign)
 mov ax,8
:row_evaluate
 cmp ax,1	;compare height counter (ax) over one
 js end_of_blitter
;----------------------------------
mov bx,[bp+10]	;get col
mov bx,[bx]
or bx,bx	;compare col (bx) against zero using 'or' trick
jns col_greater_than_zero
 ;===if col less than zero
 mov cx,bx
 neg cx
 add bx,8	;subtract col from eight to get count
		;both source and destination are unchanged
 jmp col_evaluate
:col_greater
 ;===else col zero or greater
 add di,bx	;add column ofset to destination
		;source remains unchanged
 xor cl,cl	;make pre-shift (cl) equal to zero
 neg bx
 add bx,140	;add 140 to col to get width
 cmp bx,8
 js col_evaluate;width is less than eight if positive (no sign)
 mov bx,8
:col_evaluate
 cmp bx,1	;compare width counter (bx) over one
 js end_of_blitter
;
mov dx,140	;move 320 into wrap distance (dx)
sub dx,bx	;determine actual wrap distance
		;by subtracting width from 320
;
mov bh,bl	;move in variables
mov bl,al
;
mov al,[bp+12]	;move in color value
;
;----------------------------------
cld
:next_byte
lodsb		;load byte from source into ah
shl ah,cl	;pre-shift the bytemap to adjust for column ofset
:next_bit
shl ah,1	;shift the bytemap by one to set carry flag
jnc do_not_write
 stosb
 dec bh
 jnz next_bit
 jmp done_with_byte
:do_not_write
 inc di
 dec bh
 jnz next_bit
:done_with_byte
inc si
add di,dx
dec bl
jnz next_byte
;----------------------------------
:end_of_blitter
pop bp		;restore saved variables
pop es
pop ds
retf