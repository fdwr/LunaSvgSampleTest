=====================
Simple SpriteView 0.4, 5-10-98, FDwR
=====================
  Beware, this is an example to show how to make a viewer, so it a little
more technical (and informative) than most viewer readme's.

==What it is==:
  For anybody who is interested in SNES/GameBoy graphics, this source is
written for Qbasic. This is not meant to outshine any other existing viewers
- and it definitely won't, being written in Qb - but unlike with C code, you
can trace through this one to see what happens and how it does it. That is
only if you care about how graphics are converted; if you don't, then this
still has some advantages that other viewers do not have. The most important
feature of this one is that is supports loading of game palettes from
snapshots so that while searching through the ROM, the images look like they
were meant to. I say do them justice with their true colors :-) It even comes
with five default screen palettes that should make finding sprites a little
easier. You can also view up to six graphics modes used by the SNES (and the
two used by GameBoy too). Although an earlier version was not released before,
this was technically the first to support 3bitplane tiles, the correct
8bitplane format, and mode 7 tile format (I might be wrong about 8 bitplanes,
did X-char have it right?). Actually, I think it still is the only one to
view mode 7 tiles. It is no longer the only one to export the viewing window
to a picture file (PCXs). SMC-Ripr 1.0 by Magnus Runesson also supports those
first two modes and exports screenshots (TGAs). My screen interface is not
all that pretty - it' just supposed to work. For a cool GUI, try SMC-Ripper,
or for speed, try Nagav. This one isn't horribly slow either. I know because
it was written on a 386 and works decently (thanks to my 32bit assembly).


==What's new==
  Everything, this is the first version I released.


==Requirements==
  One PC, that's pretty much all
  Well, of course it needs to be a 386+ (32bit registers),
    but I can pretty well assume you have that topped
  VGA graphics (320x200x256) are probably also the least of your worries
  Memory can be less than 2MB and be just fine (although if your computer is
    just 2MB, I don't know how you even got this program)
  Speed is like anything else, the faster the better, but it won't beep at
    you even on an old 25MHz 386
  In case you have not noticed by now, this prog does not have anymore than
    it needs to simply function (no fancy GUIs or anything)


==What to do==
  When it starts, just type in the filename of the ROM to view and press
    Enter. If you need a list of what files are where, you can use wildcards
    to display only ROMs by typing '*.smc'. Since some ROM images are stored
    with other extensions, you just replace 'smc' with the different ending,
    or just list everything with '*.*'. Since it really just calls the command
    prompt, all the same switches that you would use for a normal listing
    (like 'p' for page) will work. If the file is in another directory, just
    type the full path or the path alone and press Enter to change directory,
    then the name. Anywhere you see a prompt like this, you can get a file
    listing or change the directory. You can also just include the filename
    behind the executable if you have Qb 4.5. If you just press Enter without
    entering a name, the viewing window will simply be blank.
  Once the junk shows up on the screen (and I do mean it looks like 'junk'),
    you should know how to use the arrow keys and all that - like every other
    viewer program. Just in case you haven't already seen every other viewer,
    here are the keys for you.


==Keys==
-The Basics-
Enter  Return to the file prompt to choose a different ROM to view
       Technically, any file can be viewed, but only ROMs show something
Esc    What else, it quits
F1     Again, what else, although I don't know if it is really all that
       helpful
Q      Qbasic code, why would you want to switch to the slower Qb code? well
       if you want to see the translating code as it goes, or if you want
       bitplane filtering stuff or mode 7 (yes, unfortunately, I have not
       implemented it in the assembly yet)

-Scrolling and viewing-
<The first three are almost too obvious to waste words on>
Up Down     Move one row (eight pixel rows)
Left Right  Move one tile (eight pixel columns)
PgUp PgDn   Jump a page forward or backward (24 rows)
+ -         Move one single byte forward or backward, shifting bitplanes
            Used a lot for compressed graphics
* /         Change wrap width, this is useful for images that do not conform
            to the standard 16 tiles width
G #???      Jump directly to a position entered by number (why does nobody
            else have this, it really helpful ?)
1-8         Select the bitmode, actually the acceptable bitmodes are 1,2,3,
            4,7,8

-Palette changing-
F2-F7    Change to one of six palettes, the first one (F2) is yours and the
         last five are preprogrammed palettes
F8       Transfer screen palette into user palette, usually not very useful;
         but if you want to change a preprogrammed palette, it must first be
         copied to the user palette for editing
         Be sure to save any previously edited palette before using this
F9 F10   Change palette page, forward or backward by number of colors
F11 F12  Adjust palette base forward or backward by one single color
L        Load a palette from a picture or user saved palette
         Be sure to save any previous edited palette before using this
M        Toggle between normal 256 shade palettes and 64 shades
V        View/Edit current palette, change values, move colors around
P        Save the current user palette to a PAL file
W        Save snapshot of ROM in current window (with palette)
F #???   Shift entire palette forward or backward by value

-Keys in the palette editor-
<Press V to get into it>
Up Down          Move the cursor around vertically
Left Right       Move the cursor around horizontally (pretty simple)
Space            Grab a color, or drop a color
BckSpc           Cancel grabbing of a color
Tab              Switch between swap and overwrite color drop
Enter            Change a color's RGB values manually
                 Type a new value or just Enter again to cancel
Esc              Return viewing

-Other keys you probably won't use very much, but are listed anyway-
<These are only for complex ROMs that have a lot of confusion>
T #???  Change tile size
        Most people can ignore this one, it is used for figuring out those
        strange bitmodes that have not been documented yet
        The tile size is automatically reset when you change the bitmode
R #???  Change row spacing by number
        Another debugging feature that will for most games just mess things
        up (was testing it out on Zelda)
Ins Del Change row spacing a single byte more or less

<Note that these features are only available in Qbasic viewing mode (for now)>
S  Set to view only a single bitplane (a sliver)
E  Exclude only one bitplane
B  Set current bitplane to single out or exclude
A  Restore to all bitplanes on

==A few words on various things==
  When you have the right palette, it can make it (A) easier to find images,
rearrange the colors. To make one, you can either manually edit the colors by
eye, (ya right) or just load pure palettes from snapshots. SNeSe always saves
PCXs. Snes9x can save as GIFs or PCXs depending on how 'SnapFormat=' line in
'Snes9x.ini' is set to PCX.

  When you first load a palette, things might not look right because you are
looking at the wrong page. Use Ins/Del to page through them until you come
to the right one. Note that the palette might not have the right colors for a
certain character anywhere in it (no matter what page you select) if that
character is not in the snapshot. Game palettes are dynamic, continually
changing as you travel from level to level (or even room to room), removing
old colors and replacing them with new colors for the current scene. So even
though the right colors might still be in that palette, even if that sprite
was not on the screen, you are gauranteed to have them if he/she is.

  To help, SpriteView has preprogrammed palettes for different images.
Sometimes one palette will be better than another. Often times the sine
rainbow works well for a vivid display, but other times the grayscale turns
out the best. Here is the list of six palettes: F2=yours, F3=ascending gray,
F4=inverse gray, F5=default video (same color as most other tile viewers),
F6=sine rainbow (the smoothest), F7=old rainbow. NAGA is fast, but only has
one set of colors. VISOR and X-Char also had the same boring palette.
SMC-Ripr does let the user manually change the color values :-), but currently
has no preprogrammed color schemes.

  If your display looks like something, but out of place, try the +/- to see
if it gets fixed. Most of the time, they just mess things up though. One
obvious reason could be that you are just looking at it using the wrong mode
or it might not be graphics at all. Often times level data will make you
think there is some sort of picture there; however it is also possible that
it is using some unknown bitmode. I never said I found them all, especially
since ROMs can store their data in a format different from the native format
in the SNES/GameBoy VRAM (Video RAM). In that case, the bitplane filters
might help a little; they helped me to find how 3bit tiles were stored in
Zelda :-)

  SpriteView uses 256 shade PALs for more color resolution (although not
visible on the mode 13 screen), but it can also load/save 64 shade PALs like
used for SMC-Ripr too if you need to use one. Just press 'M' to change the
palette shade mode.

  The assembly helps to drastically speed up the tile blitting, which helps
to finds more images faster :-) If anybody wants to use it in their own viewer,
I don't care, as long you let people know who wrote it. If you think the asm
could be improved, I would be interested in knowing how.


==Basic SNES tile format for those that care, also applies to GB==
  If you have ever done any reading on the SNES/GameBoy sprite formats, you
probably know that all images, not just sprites, are divided into 8x8 tiles.
Exactly why they do it this way, I have no idea; but somehow it is faster for
the hardware to deal with a bunch of little sections rather than a simple
continuous image. To make things even more confusing, all modes except the
SNES mode 7 format (which still uses 8x8 tiles), store tiles as bitplanes,
with multiple monochrome layers built on each other to build a full color.

  The tile is arranged from right to left (reverse order), top to bottom.
Each byte represents one row of eight pixel bits (not complete pixels).
The number of bytes needed for a single complete row depends on the color
depth, or actually the number of bits needed to represent that many colors.
Bitmode 1 would take one byte for a single row; bitmode 4 would need four.
Unlike most PC graphics formats though, instead of all the bits of each pixel
being stored next to each other, they are stored with parallel bits of other
pixels. The the first bits of a complete eight pixel row are stored in the
first byte; the eight second bits are stored in the second byte, third bits
in the third byte, and so on it goes for as many bits as it takes to express
the necessary colors needed for that tile (from 2 colors to 256). To make a
whole pixel, all the separate bits are ORed until the desired bit depth is
achieved. Then the pixel can simply be written to the screen.

  For example, if a complete row of 4bit (16 color) pixels had a sequence of
<4,0,2,7,6,10,15,0> it would be stored like this:

  Pixels:          Bitplanes:

          0123          01234567
     зддддеее╢        здеееееее╢
  0 де 4  0100     0 де 00000110  byte 0
  1 де 0  0000     1 де 10011010  byte 1
  2 де 2  0010     2 де 00111110  byte 2
  3 де 7  0111     3 да 00010010  byte 3
  4 де 6  0110
  5 де 10 1010
  6 де 15 1111
  7 да 0  0000

  Notice how the vertical column (parallel bits) become the horizontal rows
of each bitplane, and how adding another byte to the bitplanes would
essentially add an extra bit to each of the eight pixels (to make 32 colors).

  Note that each pixel value is actually an index into a 16 color palette
page. The 6 does not mean to plot an absolute color there, but to plot the
color at index 6 in the current palette page - that RGB value could actually
be anything. I heard that there are 16 palettes of 16 colors each in the
total 256 color main palette, but only 8 of those can be used for sprites?
It seems like a severe limitation, but somehow those palette masters make the
most out of it and manage to make the game look like they have more colors
than they really do. That limitation is actually helpful to us, because it
arranges each palette page into a nice orderly sequence.

  I do understand the bitplane separation deal somewhat; it is easier for the
games to convert one bitmode to another if it does not need to do a lot of
bit shifting and only mess with whole bytes. If it needed to convert a
compressed 2bit image to a native 4bit sprite, it only needs to fill in the
empty bitplanes 2 and 3 (single bytes) instead of respacing each of the bits
for each of the eight pixels. Bty, the SNES can only handle 4bit "sprites",
all other bitsize tiles are blit to the screen as static images (could some-
body out there in emulation world who knows, please tell me how the tiles of
playfields are blit, such as the scrollable levels in MarioWorld or Zelda).

  Sadly, if you were actually starting to understand it, here is where it
becomes a little crazy. It's easy enough to get that each tile is stored as
multiple monochrome tiles (1bit) simply layered upon each other, but they
can't just store them in a sensible order with each bitplane after the other.
Instead, the row planes are interlaced with each other in a strange format.
The second bitplane comes immediately after the first, but the third comes
16 bytes after the first. Then the fourth comes immediately after the third,
and the fifth comes 16 after the third (32 after the first) and so on...
Just keep on doing that until you have reached the number of bitplanes for
that tile, then jump back to the beginning and add 2 to it. Even worse, since
the tiles can actually be stored in a completely different manner from the
cartridge ROM to the internal VRAM, they might not even follow this format
(the native SNES format the PPU understands).

  Currently there is no document that explains the various formats used by
games to store their tiles in the ROMs. They do talk about how the tiles are
arranged in the VRAM, but between reading from the ROM and displaying on the
screen, there could be any type of translation done to it; however, most of
the time for simplicity, the tiles are stored just the same as they would be
in the VRAM (luckily for us). For SpriteView to handle all of these different
bitmodes, each one uses a simple jump table. This readme does not contain the
jump tables, but stay tuned for a doc of my own (or just take a look at the
TileTran asm).


==Left to do==
-Try decipher what cockamaney compression Mario and many other odd games
  use for their tile storage
-See how many other unknown formats there are out there
-Support 8x12 tiles sizes
-Find out how Sega games store their sprites
-Fix palette so that text does not dissappear
-Add plane filtering and mode 7 to assembly
-Wait for feedback from anybody that gets some use out of this prog

-Although I do know NES tiles are stored, I am not going to add them because
  this is an 'SNES' viewer and there a plenty of other editors out there that
  can work with them.

  Until I find out some more modes, or somebody tells me about a bug, there
is nothing great on the horizon for this. That is pretty much all. SpriteView
is just an expanded example to show how you might view sprites (although I've
gotten more use out of SV than any other viewer yet).


==Other SNES viewer/editors==
  If you want some real editing, here are some good ones:

Nagav by L. Bontes, the first viewer/editor I ever saw
   The fastest viewer, with variable tile sizes
   SNES:1,2,4/NES:1,2/GB:1,2
VISOR by Lord Esnes, a preliminary work ;-)
   Last time I checked it was sort of slow, don't know about now ??
X-Char by Planet-X software, a little confusing
   SNES:1,2,4,8/NES:1,2/GB:1,2
SMC-Ripper by Magnus Runesson, so far the best
   Great editing, large screen resolution, soon to have palettes and support
   other formats
   SNES:1,2,3,4,8/NES:1,2/GB:1,2

There are also plenty of good GameBoy sprite editors, however I mainly focus
on the SNES viewers since the SNES has all my favorite games. If there was a
good one I left out, tell me about it; these are just ones I've found.


==Thanks to==
-Louis Bontes for making the first viewer/editor I ever saw (Naga)
-VileWrath for his example code (:-)
-Magnus Runesson for letting me see his source to the SMC-Ripr
-Corsair, Dax, Kari, and Yoshi for leaving behind their docs on the net
-Savoury Snax for explaining how sprites could be stored in a different form
  on the cartridge than in the VRaM
-Everybody who is nostalgic when it comes to their old favorite characters


==History, in case your interested==
Discovered the world of emulation and download two tile viewers (Naga and X-char)
Read a little in various docs about how SNES images are stored as 8x8 tiles
 (no offense, but most were not too helpful)
--0.0-- (2-8-98)
Downloaded example Basic code from VileWrath's page (finally get an example :-) thankyou!
Reduced size of tile drawing code and made it accept bitmodes 2,4
Bitmodes were changed by pressing the number keys
Added an gray palette
--0.1--
Added some much needed scrolling ability and Goto
Interleaved the tile drawing with retrieving of key input
  Waiting for the entire screen to fill up before you could move was just too
  slow (we've all heard that annoying 'key buffer full' beep)
Added the ability to change the viewing wrap width, for unusual length strips
Discovered 8bit arrangement (used in Mario AllStars title and selection screen)
Rewrote the gray palette to be dynamic and added inverse gray
--0.2--
Added plane separation, and exclusion
Discovered bitmode 3 used by many ROMs (including my favorite)
  Surprised that nobody else knew about it by now...
  Separation of the bitplanes and exclusion of certain ones was the feature
  that gave me the chance to understand 3bit mode for Zelda. Without this
  feature, I'd still be totally confused on it. Since there might be a few
  more modes left out there in other ROMs, I simply left these 'debugging'
  options in and added a user interface to work with them.
Sent the 3bit and correct 8bit format to Magnus Runesson (author of SMC-Ripr)
Implemented a pointer table to reduce redundant code, instead of a separate
  routine or each bitmode and such
--0.3--
Inlcuded a generic file loading prompt, with directory listing ability
Put in some cheap help
Added the most important palette yet, palettes from snapshots of a game
  Able to import screenshot palettes from GIF, PCX or bitmap images
Threw together a simple (but effective) palette editing screen
  Colors can be now moved around and such
Let the user save the edited palettes to PAL files and reload them
Added the ability to save the current window (whatever bitmode) to a PCX file (that took the longest to get right (:-)
Find the helpful Corsair+Kari doc long after I actually needed it
Finally got mode 7 format right (or at least I think - does anybody know any
  games with good mode 7 images in them?)
Added two useful false color palettes for 256 color modes
Put in a row alignment to see if it would help with some shifted images
--0.4-- (5-10-98)
(before this version, I would have just embarassed myself)
Six bitmodes are now supported
Sped up the code even more with a little assembly - 9x or so  (:-)
  (if it gets anymore advanced though, I might as well use C)
Put the color overwrite/swap toggle in the palette editor
Added manual RGB value entry in palette editor
Rewrote the palette page selecting to be dynamic, any user specified value
Cleaned it up for people to actually be able to understand it

And that brings us up to date...


==Comments, Questions==
If you want to know something about SpriteView or report a bug, please tell
me (I don't get much mail anyway). If you do not like SpriteView, then you
didn't have to download it :). If you want to ask about something about about
SNES graphics or Gameboy, I'll try to help (at least attempt to find some
docs out there on it first though :-) This prog does not have all the sprite
formats yet so if you have any detailed info on them, please share the
knowledge; or if you'd like to help me discover some of the elusive remaining
SNES sprite formats, send me a letter...

Please direct criticism to nobody@nada.com
Otherwise, FDwR@Juno.Com :-)

