;2001-09-21 Yeah! I can honestly say now that this sound code is at least as
;(and in some cases more) compatible with various sound cards as most other
;sound using programs.
;
;SpcTool (great program) has problems with unusual configurations. OpenSpc
;works nearly all the time. Impulse Tracker seems to always work no matter
;what, so it was my role model.
;
;For the ultimate challenge, I need to test it on my grandma's unforgiving,
;oddball, synthesizer-less sound card...
;
;2001-09-20 Add acknowledgment of any pending interrupts left behind by other
;           programs (after playing SpcTool, I occasionally noticed an
;           initial immediately after Spc2Midi started the sound transfer)
;           Fix 64k bank crossing (was crashing DOSKEY! ;-).

; Functions
;   GetSbAddress
;   InitSbSound
;   InitDmaTransfer
;   ReadSbDsp
;   WriteSbDsp
;   TimedWait
;   TransferWave8bit
;   TransferWave16bit

BITS 32
GLOBAL _WdosxStart

NumStringMaxLen equ 10

SbAdr:
;.Timer1Count    equ 2   ;incremented every 80 microseconds
;.Timer2Count    equ 3   ;incremented every 320 microseconds
;.TimerControl   equ 4
;.TimerReset     equ 128 ;clears timer expired flags in port 388h
;.Timer1Mask     equ 64
;.Timer2Mask     equ 32
;.Timer1Start    equ 1
;.Timer2Start    equ 2
.Reset          equ 6
.Fm             equ 8
.Read           equ 0Ah
.Write          equ 0Ch
.WriteStatus    equ 0Ch
.ReadStatus     equ 0Eh
.Ack8bit        equ 0Eh
.Ack16bit       equ 0Fh

SbCmd:
.MidiOut        equ 38h
.ExitDma8bit    equ 0DAh
.ExitDma16bit   equ 0D9h
.PauseDma8bit   equ 0D0h
.PauseDma16bit  equ 0D5h
.GetVersion     equ 0E1h

Pic:
.Mode1          equ  20h
.Mode2          equ 0A0h
.Mask1          equ  21h
.Mask2          equ 0A1h

;==============================
section .data
Sound:
align 4
.IoPort:        dd 220h
.FmPort:        dd 388h
.MpuPort:       dd 0;330h       ;300/330
.MixerPort:     dd 220h
.CardVersion:   dd 0            ;2.1,3,4
.Ldma:          dd 4            ;8bit memory channel (sentinel value set to 4 because DMA channel 4 is invalid)
.Hdma:          dd 4            ;16bit memory channel
.DmaChannel:    dd 4            ;last used channel
.ChannelsOff:   dd -1           ;channels to turn off soon
.SampleRate:    dd 22050
.HighSampleRate equ 23000       ;anything above rate this requires high speed mode (unless DSP >= 4)
.BufferPtr:     dd 0            ;address to base of sound buffer
.BufferIdx:     dd 0            ;offset within buffer of last wave data write
.BufferSel:     dd 0            ;selector to sound buffer
;.SamplesPerInt equ 2144        ;fit enough samples for the maximum playrate (64000/30=2133) and make it /16
.BufferSize     equ 4096*2      ;4k samples * 2 bytes per 16bit sample
.TransferSize   equ 65534       ;size given to sound card (for fewer interrupts)
.PicMaskPort:   dd 21h          ;PIC mask port for given IRQ 21=1-7, A1=8-15
.WaveInt:       dd 0Dh          ;interrupt number of given IRQ (wave audio)
.Irq:           db 5            ;IRQ generated by sound card at end of transfer

.PlayFlags:                     ;which sound capabilities should be used
.PlayWave       equ 1
.PlayFm         equ 2           ;believe it or not, some cards completely lack FM synthesis
.PlayMpu        equ 4
.PlayStereo     equ 8           ;stereo/mono
.Play16bit      equ 16          ;16bit/8bit
.PlayDma        equ 32
.PlayHighSpeed  equ 64
.PlayHighSpeedb equ 6
.DevCapFlags:   equ $+1         ;flags sound card capabilities, regardless of
.Flags:         dd .Play16bit   ;whether they should be used. note the bits
                                ;are exactly the same as for PlayFlags
; The sound buffer is set in low memory (<16Mb) pointed to by BufferPtr.
; The prebuffer is where multiple sounds are scaled, amplified, and merged
; before being moved to the sound card buffer. All sample calculations
; internally are 32bit, which must be clipped and converted (8bit/16bit).
; This can allow the program to play 8bit sound, but record 16bit audio.
; Physical memory reserved for it is actually twice as large as the buffer
; alone, just in case part of the allocated block crosses a 64k page.

;-------------------- informational variables only, not necessary to work
.Bits:          dd 8

align 4
SoundInts:      dd 0
TimerInts:      dd 0
MainCount:      dd 0

;==============================
section .bss
Program:
.DataSelector:      resw 1  ;necessary for sound interrupt handler
.PspSelector:       resw 1  ;selector to PSP
.ParamCount:        resd 1  ;number of parameters
.ParamTable:        resd 1  ;array of pointers to each one
.Env:               resd 1  ;command environment strings
.PicBaseMaster:     resb 1
.PicBaseSlave:      resb 1

;컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
section .text

_WdosxStart:
;==============================
Main:
    mov [Program.ParamCount],esi ;save the number of parameters,
    mov [Program.ParamTable],edi ;array of pointers to each one,
    mov [Program.Env],ebp        ;and command environment strings
    mov [Program.PspSelector],es
    mov [Program.DataSelector],ds
    push ds
    pop es

    ;virtualized interrupts already enabled
    ;mov ax,901h                ;enable interrupts
    ;int 31h

    mov ax,0400h                ;get DPMI version
    int 31h
    mov [Program.PicBaseMaster],dh ;interrupt chip base virtualization
    mov [Program.PicBaseSlave],dl

    mov edx,Text.ReadingBlaster
    call WriteString
    call GetBlasterVars
    jnc .BlasterVarOk
    mov edx,Text.BlasterErr
    call WriteString.WithEol
    jmp EndProgram
.BlasterVarOk:
    mov edx,Text.SoundEnvInfo
    call WriteString.Formatted
    call PressKey

    mov edx,Text.ResettingSb
    call WriteString
    call InitSbSound
    jnc .SoundSetup
    mov edx,Text.SbResetError
    call WriteString.WithEol
    jmp short EndProgram
.SoundSetup:
    test byte [Sound.PlayFlags],Sound.Play16bit
    jz .8bit
    mov byte [Sound.Bits],16
.8bit:
    mov edx,Text.SoundVarsInfo
    call WriteString.Formatted
    call PressKey

    call SetupTimers
    mov edx,Text.TestingDma
    call WriteString
    call InitDmaTransfer
.NextLoop:
    mov ah,1
    int 16h                     ;wait for keypress
    jnz .ExitLoop
    inc dword [MainCount]
    jmp short .NextLoop
.ExitLoop:
    cmp al,27                   ;press Escape to leave the sound playing
    je EndProgram.Now
    xor eax,eax
    int 16h

    mov edx,Text.StoppingDma
    call WriteString.WithEol
    call InitDmaTransfer.Stop
    call SetupTimers.CleanUp
    call PressKey

    mov edx,Text.ReleasingSound
    call WriteString
    call InitSbSound.CleanUp
    mov edx,Text.SoundReleased
    call WriteString.WithEol

EndProgram:
    call PressKey
    mov edx,Text.Ending
    call WriteString
.Now:
    mov eax,4C00h
	int 21h


;==============================
PressKey:
    mov edx,Text.PressKey
    call WriteString
    xor eax,eax
    int 16h
    cmp al,27
    je EndProgram.Now
    ret


;==============================
; Reads variables from BLASTER string. Assumes all settings are correct, and
; that the address, IRQ, & DMA are valid. Don't tell the user an annoying
; message like "invalid blaster setting", because as many different
; computers and different configurations are there are out there, nothing
; can be accepted as standard. However, in the unlikely event the specified
; settings are incorrect (which can happen in the wonderful world of Windows),
; prepare to crash! :/
GetBlasterVars:
    ;get DOS environment string (db "BLASTER",0)
    ;get parts  Address,Dma,Interrupt,HighDma,Mpu

%if 0 ;print strings
    mov esi,[Program.Env]
    jmp short .FirstVariable
.NextVariable:
    call WriteString
.FirstVariable:
    mov edx,[esi]
    add esi,byte 4
    test edx,edx
    jnz .NextVariable
    ret
%endif

    ;search through environment for BLASTER variable
    cld
    mov ebx,[Program.Env]
    jmp short .FirstVariable
.NextVariable:
    add ebx,byte 4
    cmp dword [esi],'BLAS'
    jne .FirstVariable
    cmp dword [esi+4],'TER='
    je .VariableFound
.FirstVariable:
    mov esi,[ebx]
    test esi,esi
    jnz .NextVariable
    stc
    ret

.VariableFound:
    add esi,byte 8              ;skip "BLASTER=" variable name
    xor ecx,ecx                 ;clear element flags

.NextElement:
    mov bl,[esi]
    test bl,bl
    je near .End
    inc esi
    cmp bl,32
    je .NextElement

;Converts hex number string in environment variable to number
;(esi=ptr to hex number string) (bl=letter)
.GetNum:
    xor eax,eax             ;set return value to zero
.NextDigit:
    mov dl,[esi]            ;get digit
    sub dl,48               ;"0"=48->0  "9"=57->9
    jc .LastDigit           ;character is less than '0'
    cmp dl,10
    jb .AddPlaceValue       ;digit is 0-9
    and dl,~32              ;make uppercase by turning off fifth bit
    cmp dl,'A'-48
    jb .LastDigit           ;character is less than 'A'
    cmp dl,'F'-48
    ja .LastDigit           ;character is greater than 'F' (15)
    sub dl,7                ;(65-48)+10  "A"=65->10  "F"=86->15
.AddPlaceValue:
    shl eax,4               ;multiply existing number by radix (16)
    inc esi                 ;move forwards one character
    or al,dl                ;add new digit
    jmp short .NextDigit
.LastDigit:

;(eax=number) (bl=letter)
    and bl,~32                  ;make uppercase
    cmp bl,'A'
    jne .SkipAdr
    mov [Sound.IoPort],eax
    add eax,byte SbAdr.Fm
    mov [Sound.FmPort],eax
    or cl,3                     ;flag both dsp address and FM synthesizer present
.SkipAdr:
    cmp bl,'D'
    jne .SkipDma
    mov [Sound.Ldma],al         ;DMA Channels 0-3
    or cl,4
.SkipDma:
    cmp bl,'H'
    jne .SkipHdma
    mov [Sound.Hdma],al         ;High DMA 4-7
    or cl,8
.SkipHdma:
    cmp bl,'I'
    jne .SkipInt
    cmp al,16                   ;compensate for hexadecimal conversion
    jb .IrqOk
    sub al,6                    ;16->10, 21->15
.IrqOk:
    cmp al,2                    ;hack exception for cascaded IRQ 2
    jne .NotIrq2
    add al,7                    ;force 2 to 9
.NotIrq2:
    mov [Sound.Irq],al
    ; get interrupt number based on IRQ
    cmp al,8
    jb .LowIrq
    and al,7
    add al,[Program.PicBaseSlave]
    jmp short .SetInt
.LowIrq:
    add al,[Program.PicBaseMaster]
.SetInt:
    mov [Sound.WaveInt],al      ;keep interrupt number
.SkipInt:
    cmp bl,'P'
    jne .SkipMpu
    mov [Sound.MpuPort],eax
    or cl,16
.SkipMpu:
;    cmp bl,'M'
;    jne .SkipMixer
;    mov [Sound.MixerPort],eax
;    or cl,32
;.SkipMixer:
;    cmp bl,'T'
;    jne .SkipType
;    mov [Sound..],eax
;    or cl,32
;.SkipType:
    jmp .NextElement

.End:
    clc
    ret


;==============================
; Resets/detects sound card, allocates sound buffer, and sets IRQ interrupt
; handler. If the sound card does not exist, is at the wrong address, will
; not reset (because some other program already has control of it), or the
; sound buffer could not be allocated, the routine will return failure.
;
; Does absolutely nothing to initialize DMA channels, nor does it send any
; commands the sound card for transfer. That is all taken care of by
; InitDmaTransfer.
;
; write 1 to reset
; wait 3us
; write 0 to reset
; check for 0AAh from read port
; get sound card DSP version
; allocate's wave buffer
; clear buffer
;
; () (cf=error)
InitSbSound:
    and byte [Sound.DevCapFlags],~(Sound.Play16bit|Sound.PlayWave)

    ; detect sound card's existance and willingness to reset
    mov edx,[Sound.IoPort]
    mov al,1
    add dl,SbAdr.Reset
    out dx,al                   ;write 1 to reset port
    mov ecx,2                   ;delays 15-30us (need 3us)
    call TimedWait
    xor al,al
    out dx,al

    add dl,SbAdr.ReadStatus-SbAdr.Reset
    mov ecx,67                  ;set timeout to 1 millisecond just in case
.Wait:                          ;67 = .001 / .000015085
    in al,dx
    test al,al
    jns .NotReady
    add dl,SbAdr.Read-SbAdr.ReadStatus
    in al,dx
    sub dl,SbAdr.Read-SbAdr.ReadStatus
    cmp al,0AAh
    je .Success

.NotReady:
    in al,61h                   ; Read timer connected to port 61h at bit 4
    and al,10h                  ; This bit toggles every 15.085 (micro sec)
    cmp al,ah
    je .Wait
    mov ah,al
    dec ecx
    jg .Wait
.Fail:
    mov ah,[Sound.DevCapFlags]
    and [Sound.PlayFlags],ah
    stc
    ret

.Success:
    ; get sound card's DSP version
    mov al,SbCmd.GetVersion
    call WriteSbDsp
    call ReadSbDsp
    cmp al,2
    jb .Fail
    cmp al,4
    jb .Not16bit
    or byte [Sound.DevCapFlags],Sound.Play16bit
.Not16bit:
    mov bh,al
    call ReadSbDsp
    mov bl,al
    mov [Sound.CardVersion],bx

    ; allocate sound buffer
    mov eax,0100h               ;allocate low memory
    mov ebx,(Sound.BufferSize*2)/16;paragraphs to grab *2 for double buffering
    int 31h
    jc .Fail
    shl eax,4
    mov [Sound.BufferSel],dx
    mov [Sound.BufferPtr],eax

    ; ensure buffer doesn't cross 64k boundary
    or eax,0FFFF0000h           ;set all bits above 64k (DMA page)
    add eax,Sound.BufferSize-1
    jnc .NoWrap
    add dword [Sound.BufferPtr],Sound.BufferSize
.NoWrap:

    ; get old interrupt handler
    mov ax,0204h                ;get protected-mode interrupt
    mov bl,[Sound.WaveInt]      ;wave audio interrupt
    int 31h
    mov [.OldHandler],edx       ;save offset
    mov [.OldHandler+4],cx      ;save selector

    ; set new interrupt handler
    mov edx,SoundHandler
    ;mov bl,[Sound.WaveInt]     ;wave audio interrupt
    mov ax,0205h                ;set protected mode interrupt
    mov cx,cs                   ;pass our code selector
    int 31h

    ; enable interrupt by setting IRQ bit in PIC
    mov cl,[Sound.Irq]
    mov bl,254
    mov edx,Pic.Mode1           ;default to PIC1, for IRQs 0-7
    cli
    cmp cl,8
    jb .EnableLowIrq
    mov al,60h|2                ;specific EOI, in case some other program left one
    out dx,al
    in al,Pic.Mask1             ;dx=Pic.Mask1
    and al,11111011b            ;unmask IRQ 2 also because of cascaded IRQs
    out Pic.Mask1,al            ;enable slave 8259 for high IRQs
    mov dl,Pic.Mode2            ;use PIC2 instead, for IRQs 8-15
.EnableLowIrq:
    mov al,cl
    and al,7
    or al,60h                   ;specific EOI, in case some other program left one
    out dx,al                   ;a few times after playing SpcTool then starting my own player, a spurious initial interrupt would occur
    inc dx                      ;mask register = mode reg + 1
    rol bl,cl                   ;enable (unmask) channel
    in al,dx
    and al,bl
    out dx,al
    mov [Sound.PicMaskPort],edx
    sti

    mov al,0D1h                 ;turn on speaker
    call WriteSbDsp

    ; mask play flags with actual capabilities
    mov eax,[Sound.Flags]
    or ah,Sound.PlayWave
    and al,ah
    mov [Sound.Flags],eax

    call .ClearBuffer

    clc
    ret

.ClearBuffer:
%if 0
    cld
    mov edi,[Sound.BufferPtr]
    xor eax,eax                 ;0 is silence for 16bit
    test byte [Sound.PlayFlags],Sound.Play16bit
    jnz .Clear16bit
    mov eax,80808080h           ;128 is silence for 8bit
.Clear16bit:
    mov ecx,Sound.BufferSize/4
    rep stosd
    ret
%elif 0
    mov edi,[Sound.BufferPtr]
    xor eax,eax
    mov ecx,Sound.BufferSize
.ClearNext:
    mov [edi],ah
    add eax,byte 111
    inc edi
    dec ecx
    jg .ClearNext
    ret
%else
    cld
    mov edi,[Sound.BufferPtr]
    mov esi,SamplesBuffer
    test byte [Sound.PlayFlags],Sound.Play16bit
    jnz .Clear16bit
    inc esi                     ;offset by one to get high byte of each word
    mov ecx,Sound.BufferSize
.ClearNext:
    lodsw
    ;mov al,ah
    xor al,128
    stosb
    dec ecx
    jg .ClearNext
    jmp short .Cleared
.Clear16bit:
    mov ecx,Sound.BufferSize/4
    rep movsd
.Cleared:
    ret
%endif

.CleanUp:
    test byte [Sound.DevCapFlags],Sound.PlayWave
    jz .IgnoreCleanUp
    and byte [Sound.DevCapFlags],~Sound.PlayWave

    mov al,0D3h                 ;turn off speaker
    call WriteSbDsp
    mov edx,[Sound.IoPort]      ;reset sound card one last time just in case
    mov al,1
    add dl,SbAdr.Reset
    out dx,al

    ; disable interrupt
    mov edx,[Sound.PicMaskPort]
    mov cl,[Sound.Irq]
    mov bl,1
    rol bl,cl
    in al,dx
    or al,bl
    out dx,al

    ; restore old interrupt handler
    mov bl,[Sound.WaveInt]      ;wave audio interrupt
    mov ax,0205h                ;set protected mode interrupt
    mov cx,[.OldHandler+4]      ;get selector
    mov edx,[.OldHandler]       ;get offset
    int 31h

    ; free buffer
    mov ax,0101h                ;deallocate low memory
    mov dx,[Sound.BufferSel]
    int 31h

.IgnoreCleanUp:
    ret


section .bss
alignb 4
.OldHandler:    resd 1
                resw 1
section .text


;==============================
; Separate from InitSbSound so that it can be called multiple times. That way
; the sample rate, bits, and stereo options can be changed within the program
; without needing to exit and restart it. Supports 8bit, high speed 8bit, and
; 16bit, but all of them in mono only (didn't care enough for stereo).
;
; Note while the DMA controller is programmed with the true buffer size, the
; sound card is given a ridiculously large value so that it signals the
; minimum frequency of pointless interrupts, since none of the sound
; processing even occurs in the handler. The handler's only purpose is to
; simply acknowledge the interrupts and return.
;
; Oddly, some sound cards always generate at least one interrupt per buffer
; transfer, regardless of the transfer size (Crystal Audio 1999) given to it.
; I think what is happening is that the legacy emulator is intercepting all
; sound related port writes (even to the DMA) and choosing to do whatever it
; wants. No big deal though...
;
InitDmaTransfer:
    ; The reason the convoluted mess immediately below this sentence is that
    ; some sound cards can actually use the 8bit DMA channels for 16bit
    ; output.
    mov ebx,[Sound.Hdma]
    cmp bl,4
    je .UseLdma
    test byte [Sound.PlayFlags],Sound.Play16bit
    jnz .UseHdma
.UseLdma:
    mov bl,[Sound.Ldma]
.UseHdma:
    mov [Sound.DmaChannel],bl
    cmp bl,4
    jae .SetupHdma

;(ebx=dma channel)
.SetupDma:
    ; set up transfer on DMA side
    mov al,bl
    or al,4
    out 0Ah,al                  ;mask DMA channel for programming
    ;mov al,bl                  ;just done above
    xor al,58h | 4
    out 0Bh,al                  ;set transfer mode (single/autoinit/write)
    ;xor al,al                  ;unnecessary since any value will work
    out 0Ch,al                  ;reset flip-flop

    mov eax,[Sound.BufferPtr]
    lea edx,[ebx*2]             ;port for address and length
    out dx,al                   ;set address low byte
    mov al,ah
    out dx,al                   ;set address high byte
    inc dl
    mov al,(Sound.BufferSize-1) & 255
    out dx,al                   ;set buffer size low byte
    mov al,(Sound.BufferSize-1) >> 8
    out dx,al                   ;set buffer size high byte
    mov dx,[.DmaPageTbl+ebx*2]  ;get page register for channel
    shr eax,16                  ;get top four bits of buffer ptr
    out dx,al                   ;set page
    mov al,bl
    out 0Ah,al                  ;reenable channel for transfer

    jmp short .SetupSb

;(ebx=dma channel)
.SetupHdma:
    ; set up transfer on DMA side
    mov al,bl
    ;or al,4                    ;bit is already set anyway
    out 0D4h,al                 ;mask DMA channel for programming
    ;mov al,bl                  ;just done above
    xor al,58h | 4
    out 0D6h,al                 ;set transfer mode (single/autoinit/write)
    ;xor al,al                  ;unnecessary since any value will work
    out 0D8h,al                 ;reset flip-flop

    mov eax,[Sound.BufferPtr]
    lea edx,[ebx*4+0C0h-16]     ;port for address and length
    shr eax,1                   ;both page and offset / 2
    out dx,al                   ;set address low byte
    mov al,ah
    out dx,al                   ;set address high byte
    add dl,2
    mov al,(Sound.BufferSize/2-1) & 255
    out dx,al                   ;set buffer size low byte
    mov al,(Sound.BufferSize/2-1) >> 8
    out dx,al                   ;set buffer size high byte
    mov dx,[.DmaPageTbl+ebx*2]  ;get page register for channel
    shr eax,15                  ;get top four bits of buffer ptr
    out dx,al                   ;set page
    mov al,bl
    and al,3
    out 0D4h,al                 ;reenable channel for transfer

.SetupSb:
    ; set up transfer on SB side
    mov al,040h                 ;set time constant
    call WriteSbDsp
    xor edx,edx                 ;TimeConstant = 256-(1000000/SampleRate)
    mov eax,1000000
    div dword [Sound.SampleRate]
    neg al                      ;same as 256-x
    call WriteSbDsp

    test byte [Sound.PlayFlags],Sound.Play16bit
    jnz .16bit

.8bit:
    mov al,048h                 ;set transfer size
    call WriteSbDsp
    mov al,Sound.TransferSize & 255
    call WriteSbDsp
    mov al,Sound.TransferSize >> 8
    call WriteSbDsp

    ; if DSP version < 4 and sample rate > 23000, enter high speed mode
    ; if you try play 23001-44100hz without entering high speed, the sample
    ; rate will be clipped to its maximum 23000hz.
    cmp dword [Sound.SampleRate],Sound.HighSampleRate
    jbe .NoHighSpeed
    cmp dword [Sound.CardVersion],400h  ;>= 4.x need not high speed mode
    jae .NoHighSpeed
    or byte [Sound.DevCapFlags],Sound.PlayHighSpeed
    mov al,90h                  ;begin high-speed 8bit PCM output
    jmp WriteSbDsp
    ;ret
.NoHighSpeed:
    mov al,1Ch                  ;begin 8bit PCM output
    jmp WriteSbDsp
    ;ret

.16bit:
    mov al,0B6h                 ;begin 16bit PCM output
    call WriteSbDsp
    mov al,10h                  ;mode=16bit signed mono
    call WriteSbDsp
    mov al,Sound.TransferSize & 255
    call WriteSbDsp
    mov al,Sound.TransferSize >> 8
    jmp WriteSbDsp
    ;ret

; Public entry point
.Stop:
    test byte [Sound.DevCapFlags],Sound.PlayWave
    jz .IgnoreStop

    ; stop sound card transfer
    ; if in high speed mode
    ;   reset sound card
    ; elseif 8bit
    ;   send 8bit exit dma
    ;   pause 8bit exit dma
    ; else 16bit
    ;   send 16bit exit dma
    ;   pause 16bit exit dma
    ; endif
    btr dword [Sound.DevCapFlags],Sound.PlayHighSpeedb
    jnc .ExitLowSpeed
    mov edx,[Sound.IoPort]      ;reset sound card to exit high speed mode
    mov al,1
    add dl,SbAdr.Reset
    out dx,al
    jmp short .Stopped
.ExitLowSpeed:
    test byte [Sound.PlayFlags],Sound.Play16bit
    mov al,SbCmd.ExitDma8bit
    jz .Exit8bit
    mov al,SbCmd.ExitDma16bit
.Exit8bit:
    call WriteSbDsp
    test byte [Sound.PlayFlags],Sound.Play16bit
    mov al,SbCmd.PauseDma8bit
    jz .Pause8bit
    mov al,SbCmd.PauseDma16bit
.Pause8bit:
    call WriteSbDsp
.Stopped:

    ; disable DMA channel
    mov al,[Sound.DmaChannel]
    cmp al,4
    jbe .DisableDma
    ;or al,4 ;unnecessary since bit 2 is already set
    out 0D4h,al                 ;mask DMA channel for programming
    ;jmp short .DmaDisabled
    ret
.DisableDma:
    or al,4
    out 0Ah,al                  ;disable DMA channel
.DmaDisabled:
.IgnoreStop:
    ret


section .data
align 2
.DmaPageTbl:    dw 87h,83h,81h,82h, 8Fh,8Bh,89h,8Ah
section .text


;==============================
; Reads single byte from sound card. Many program's sound routines just have
; a tight loop here, so that if anything goes wrong, you're stuck in one of
; those great infinite loops. Personally, I can stand the thought of such
; code, so I provide a timeout by using the 15us timer. If timeout occurs,
; the routine ignores the fact that the card isn't ready and just reads it
; anyway.
;
; ()
; (al=data, ecx=success if nonzero; !edx)
ReadSbDsp:
    mov edx,[Sound.IoPort]
    add dl,SbAdr.ReadStatus
    mov ecx,67                  ;set timeout to 1 millisecond just in case
.Wait:                          ;67 = .001 / .000015085
    in al,dx
    test al,al
    js .Ready
    in al,61h                   ; Read timer connected to port 61h at bit 4
    and al,10h                  ; This bit toggles every 15.085 (micro sec)
    cmp al,ah
    je .Wait
    mov ah,al
    dec ecx
    jg .Wait

.Ready:
    add dl,SbAdr.Read-SbAdr.ReadStatus
    in al,dx
    ret


;==============================
; Writes single byte to sound card. If timeout occurs, the routine ignores
; the fact that the card isn't ready and just writes it anyway.
;
; (al=data)
; (ecx=success if nonzero; !edx)
WriteSbDsp:
    push eax
    mov edx,[Sound.IoPort]
    add dl,SbAdr.WriteStatus
    mov ecx,67                  ;set timeout to 1 millisecond just in case
.Wait:                          ;67 = .001 / .000015085
    in al,dx
    test al,al
    jns .Ready
    in al,61h                   ; Read timer connected to port 61h at bit 4
    and al,10h                  ; This bit toggles every 15.085 (micro sec)
    cmp al,ah
    je .Wait
    mov ah,al
    dec ecx
    jg .Wait

.Ready:
    pop eax
    ;add dl,SbAdr.Write-SbAdr.WriteStatus  ;same port
    out dx,al
    ret


;====================
; Quote from "CPU Independant Timer"
;
; "the perfect anwser.  It seems that there is a timer connected to port 61h
;  at bit 4.  This bit toggles every 15.085 u sec (micro sec)."
;
; (ecx=number of 15.085 microsecond loops)
; (; !ax,ecx)
;
TimedWait:
    in al,61h
    and al,10h          ;mask bit 4
    mov ah,al
.CheckAgain:
    in al,61h
    and al,10h
    cmp al,ah
    jz .CheckAgain      ;no change so loop back
    mov ah,al
    dec ecx
    jg .CheckAgain
    ret


;==============================
; Transfer prebuffer to low memory for sound card, converting wave buffer
; data to 8bit unsigned and clipping.
;
; (esi=source data, edi=destination, ecx=samples)
TransferWave8bit:
.Next:
    mov eax,[esi]
    add esi,byte 4
    add eax,32768               ;toggle sign bit for conversion to 8bit
    test eax,~32767
    jz .Valid
    sar eax,31                  ;sign extend
    not eax
.Valid:
    mov [edi],ah
    inc edi
    dec ecx
    jg .Next
    ret


;==============================
; Transfer prebuffer to low memory for sound card, converting wave buffer
; data to 16bit signed and clipping.
;
; (esi=source data, edi=destination, ecx=samples)
TransferWave16bit:
.Next:
    mov eax,[esi]
    add esi,byte 4
    cmp eax,32768
    jb .Valid
    cmp eax,-32768
    jae .Valid
    sar eax,31                  ;sign extend
    xor eax,32768
.Valid:
    mov [edi],ax
    add edi,byte 2
    dec ecx
    jg .Next
    ret


;============================================================
; Saves old timer interrupt handler and sets new one.
;
SetupTimers:
    ;save existing interrupt handler
    mov ax,0204h                ;get protected-mode interrupt
    mov bl,8                    ;timer interrupt
    int 31h
    mov [.OldHandler],edx       ;save offset
    mov [.OldHandler+4],cx      ;save selector

;    ;increase rate to more precise rate of 30hz rather than only 18.2
;    mov cx,1193182/30
;    call .SetPitRate

    mov edx,TimerHandler
;(edx=handler address)
.SetNewHandler:
    mov bl,8                    ;timer interrupt
    mov ax,0205h                ;set protected mode interrupt
    mov cx,cs                   ;pass our code selector
    int 31h
    ret

.CleanUp:
    ;restore old interrupt handler
    mov bl,8                    ;timer interrupt
    mov ax,0205h                ;set protected mode interrupt
    mov cx,[.OldHandler+4]      ;get selector
    mov edx,[.OldHandler]       ;get offset
    int 31h

    ;restore default rate of 18.2065hz
    ;xor cx,cx
    ;call .SetPitRate
    ret

;.SetPitRate:
;    cli                 ;don't want any interrupt to mess this up below
;    mov al,00110100b    ;(00:11:010:0) set counter 0, lsb/msb, mode 2, binary
;    out 43h,al
;    in al,61h           ;i/o delay
;    mov al,cl
;    out 40h,al          ;write counter low byte
;    in al,61h           ;i/o delay
;    mov al,ch
;    out 40h,al          ;write counter high byte
;    sti
;    ret

section .bss
alignb 4
.OldHandler:    resd 1
                resw 1
section .text


;==============================
SoundHandler:
%if 1
    pusha
    push ds
    mov ds,[cs:Program.DataSelector]

    ; acknowledge the interrupt
    ; According to SB documentation, the interrupt need not be acknowledged
    ; when in high speed mode, but it does no harm. So just in case some
    ; manufacturer did things their own way, acknowledge it anyway.
    ;test byte [Sound.DevCapFlags],Sound.PlayHighSpeed
    ;jz .SkipAck
    mov edx,[Sound.IoPort]
    add dl,SbAdr.Ack8bit
    test byte [Sound.PlayFlags],Sound.Play16bit
    jz .Use8bit
    ;add dl,SbAdr.Ack16bit-SbAdr.Ack8bit
    ; Why two stupid ports instead of just one for both 8bit and 16bit?
    inc dl
.Use8bit:
    in al,dx
.SkipAck:

    mov eax,[SoundInts]
    xor edi,edi
    call NumToScreen
    inc dword [SoundInts]

    cmp byte [Sound.Irq],8
    mov al,20h
    jb .LowIrq
    out Pic.Mode2,al
.LowIrq:
    out Pic.Mode1,al

    pop ds
    popa
    sti
    iret
%else
    push eax
    push edx

    ; Acknowledge the SB's interrupt so it doesn't send it again
    ; Doing this simple step below is gravely important. Without it, the sound
    ; card may continue sending endless more interrupts to the point that the
    ; stack overflows and the pc triple faults - most annoying!
    mov edx,[cs:Sound.IoPort]
    add dl,SbAdr.Ack8bit
    test byte [cs:Sound.PlayFlags],Sound.Play16bit
    jz .Use8bit
    ;add dl,SbAdr.Ack16bit-SbAdr.Ack8bit
    inc dl
.Use8bit:
    in al,dx

    ; allow the PIC to signal more interrupts
    pop edx
    cmp byte [cs:Sound.Irq],8
    mov al,20h
    jb .LowIrq
    out Pic.Mode2,al
.LowIrq:
    out Pic.Mode1,al
    pop eax
    sti
    iret
%endif

;==============================
TimerHandler:
    pusha
    push ds
    push es
    mov ds,[cs:Program.DataSelector]

    mov eax,[TimerInts]
    cmp eax,3*18
    jb .NoSound
    test byte [Sound.DevCapFlags],Sound.PlayWave
    jz .NoSound
    ;call InitSbSound.Release
    ;mov eax,[TimerInts]
.NoSound:
    mov edi,1*160
    call NumToScreen
    mov eax,[MainCount]
    mov edi,2*160
    call NumToScreen
    mov eax,esp
    mov edi,3*160
    call NumToScreen
    mov ebx,[SoundInts]         ;calculate timer/sound ratio
    xor edx,edx
    mov eax,[TimerInts]
    test ebx,ebx
    jle .NoRatioDiv
    div ebx
    mov edi,4*160
    call NumToScreen
.NoRatioDiv:

    inc dword [TimerInts]

    pop es
    pop ds
    popa
    jmp far [cs:SetupTimers.OldHandler]
;.NoChain:
;    mov al,20h                  ;acknowledge interrupt
;    out 20h,al
;    pop es
;    pop ds
;    popa
;    iret


;==============================
; Turns a 32bit number into a decimal (or other) string, writing it to edi.
; By default, it converts a number to a decimal string, maximum of ten
; characters, stored in NumToString.Buffer. To change where the string is
; stored, the length, or radix, these variables can be passed to a different
; entry point. If an alternate destination is supplied, the default is a
; decimal number up to ten characters. If a length is supplied, so must the
; destination; and if the radix, so must both destination and length be given.
;
; (eax=number, ?edi=destination, ?ecx=maximum length, ?ebx=radix)
; (ecx=offset of first significant digit, ebx=radix used; esi)
NumToString:
    mov edi,.Buffer
;(edi=destination)
.ToDest:
    mov ecx,NumStringMaxLen ;default maximum of ten characters, since the largest 32bit number is 4 gigabytes
;(ecx=number of digits, edi=destination)
.OfLength:
	mov ebx,10              ;base of the decimal system
;(ebx=radix, ecx=number of digits, edi=destination)
.OfRadix:                   ;for hexadecimal and binary (even octal)
	xor edx,edx             ;set top 32 bits of quotient to zero
    lea edi,[edi+ecx-1]     ;start from rightmost character in number
.NextChar:
	div ebx                 ;divide number by the decimal base
    mov dl,[.NumberTable+edx] ;get ASCII character from table
	;add dl,48              ;make remainder into an ASCII character
	mov [edi],dl            ;output result
    dec edi                 ;move backwards one character
	test eax,eax            ;see if we are done with the number
	jz .FillInBlanks        ;nothing but zeroes left
	xor edx,edx             ;set edx to zero again for next division
	dec ecx                 ;one less character to output
	jnz .NextChar
	ret

.FillInBlanks:
    mov al,[.FillChar]      ;fill in with spaces, zeroes, asterisks
    dec ecx                 ;one less than current count
    mov edx,ecx
    std                     ;move backwards
    rep stosb               ;for number of characters remaining
    mov ecx,edx             ;return offset of first digit
	ret

section .data
.FillChar:      db ' '
.NumberTable:   db "0123456789ABCDEF"
section .bss
.Buffer:    resb NumStringMaxLen
section .text


;==============================
; Turns a 32bit number into a decimal (or other) string, writing it to a
; screen offset. This routine is specifically used by the interrupt handlers.
; By default, it converts a number to a decimal string, maximum of ten
; characters, written to the text screen. To change where the string is
; stored, the length, or radix, these variables can be passed to a different
; entry point.
;
; (eax=number, edi=screen destination, ?ecx=maximum length, ?ebx=radix)
; (ecx=offset of first significant digit, ebx=radix used; esi)
NumToScreen:
    mov ecx,NumStringMaxLen ;default maximum of ten characters, since the largest 32bit number is 4 gigabytes
;(ecx=number of digits)
.OfLength:
	mov ebx,10              ;base of the decimal system
;(ebx=radix, ecx=number of digits)
.OfRadix:                   ;for hexadecimal and binary (even octal)
    add edi,0B8000h
;(ebx=radix, ecx=number of digits, edi=destination)
.ToDest:
	xor edx,edx             ;set top 32 bits of quotient to zero
    lea edi,[edi+ecx*2-2]   ;start from rightmost character in number
.NextChar:
	div ebx                 ;divide number by the decimal base
    mov dl,[.NumberTable+edx] ;get ASCII character from table
	;add dl,48              ;make remainder into an ASCII character
	mov [edi],dl            ;output result
    sub edi,byte 2          ;move backwards two characters
	test eax,eax            ;see if we are done with the number
	jz .FillInBlanks        ;nothing but zeroes left
	xor edx,edx             ;set edx to zero again for next division
	dec ecx                 ;one less character to output
	jnz .NextChar
	ret

.FillInBlanks:
    mov al,[.FillChar]      ;fill in with spaces, zeroes, asterisks
    dec ecx                 ;one less than current count
	mov edx,ecx
    jmp short .FillStart
.FillNext:
    mov [edi],al            ;for number of characters remaining
    sub edi,byte 2          ;move backwards two characters
    dec ecx
.FillStart:
    jg .FillNext
    mov ecx,edx             ;return offset of first digit
	ret

.FillChar       equ NumToString.FillChar
.NumberTable:   equ NumToString.NumberTable
.Buffer:        equ NumToString.Buffer


;컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
; Writes an ASCIIZ string to screen, not terminated by stupid "$"
; (edx=ptr to string)
; (edx; esi)
WriteString:
    mov ecx,1024            ;maximum length of characters
	mov edi,edx             ;copy source for string length search
	mov eax,ecx             ;make a copy of max length for later and set al to null
    ;xor al,al              ;;look for null
    cld
    repne scasb             ;search for the end
    ;neg ecx                ;;get negative count
    ;dec ecx                ;;minus the null at the end
	not ecx                 ;negate count and subtract null at the end
	add ecx,eax             ;get length
; (edx=ptr to string, ecx=count)
.OfLength:
    mov ebx,1               ;console output handle
    mov ah,40h              ;DOS: Write to file
	int 21h
    ret

; Writes ASCIIZ string and appends end of line
; (edx=ptr to string)
.WithEol:
    mov ecx,1024            ;maximum length of characters
	mov edi,edx             ;copy source for string length search
	mov eax,ecx             ;make a copy of max length for later and set al to null
    ;xor al,al              ;;look for null
    cld
    repne scasb             ;search for the end
	not ecx                 ;negate count and subtract null at the end
    dec edi
    lea ecx,[ecx+eax+2]     ;get length
    push dword [edi]
    mov dword [edi],120D0Ah
    call .OfLength
    pop dword [edi]
    ret

%if 0
; (eax=number)
.Number:
    call NumToString
    lea edx,[NumToString.Buffer+ecx]
    neg ecx
    add ecx,NumStringMaxLen
    jmp short .OfLength
%endif

; (edx=formatted string, dwords Number1, Number2...)
.Formatted:
    lea esi,[esp+4]         ;set number parameter ptr to first one

.FormattedNext:
    ; get length of string part up to either next % or end
    mov ecx,1024|"%"        ;maximum length of characters
	mov edi,edx             ;copy source for string length search
    mov eax,ecx             ;make a copy of max length for later and set al to null
    ;xor al,al              ;look for null
    cld
    repne scasb             ;search for the end
	not ecx                 ;negate count and subtract null at the end
    add ecx,eax             ;part length = previous length - remaining length
    call .OfLength
    mov bl,[edi]
    lea edx,[edi+1]          ;advance to next section of string
    test bl,bl
    je .FormattedEnd

    ; check if number is pointed to in string or on stack
    cmp bl,'p'
    je .FormattedPtr
    mov eax,[esi]
    add esi,byte 4
    jmp short .FormattedStack
.FormattedPtr:
    mov ebx,[edx]               ;indirect pointer
    mov eax,[ebx]
    add edx,byte 5
    mov bl,[edx-1]
.FormattedStack:

    ; determine number type and print accordingly
    push edx                ;save text ptr
    push dword .FormattedNum
    cmp bl,'b'
    je .FormatByte
    cmp bl,'d'
    je near NumToString
    cmp bl,'h'
    je .FormatHex
    cmp bl,'%'              ;two % in a row means not a control code
    jne .FormatNone
    push edx
    mov dl,bl
    mov ah,2
    int 21h
    pop edx
.FormatHex:
    mov ebx,16
    mov ecx,NumStringMaxLen
    mov edi,NumToString.Buffer
    jmp NumToString.OfRadix
.FormatByte:
    movzx eax,al
    jmp NumToString
.FormattedNum:
    lea edx,[NumToString.Buffer+ecx]
    neg ecx
    add ecx,NumStringMaxLen
    call .OfLength
.FormatNone:

    pop edx                 ;retrieve text ptr
    mov ecx,[esp]           ;retrieve total remaining string length
    jmp .FormattedNext

.FormattedEnd:
    ret


;==============================
section .data
align 2
                db "Wave"
SamplesBuffer:  incbin "sounddmp.raw",0,Sound.BufferSize*2

Text:
.ReadingBlaster:db "Parsing BLASTER environment variable...",0
.BlasterErr:    db "Missing",0
.ResettingSb:   db "Resetting sound card...",0
.SbResetError:  db "Sound card would not reset.",0
.TestingDma:    db "Testing DMA transfer...",0
.StoppingDma:   db "Stopping transfer and disabling DMA channel",0
.ReleasingSound:db "Releasing sound...",0
.SoundReleased: db "IRQ disabled, buffer freed",0
.PressKey:      db "Press a key...",13,0
.Ending:        db "Yeah! No freezes or crashes. Program ending :-)",0
.Eol:           db 13,10
.SoundEnvInfo:  db "Ok",13,10
                db "Address:     %p",
                dd Sound.IoPort
                db "h",13,10,"DMA Channel: %p"
                dd Sound.Ldma
                db "b",13,10,"High DMA:    %p"
                dd Sound.Hdma
                db "b",13,10,"IRQ Line:    %p"
                dd Sound.Irq
                db "b",13,10,"Interrupt:   %p"
                dd Sound.WaveInt
                db "h",13,10,"MPU401 IO:   %p"
                dd Sound.MpuPort
                db "h",13,10,10,"%",0
.SoundVarsInfo: db "Reset, buffer allocated, IRQ enabled",13,10
                db "Sound card version: %p"
                dd Sound.CardVersion+1
                db "b.%p"
                dd Sound.CardVersion
                db "b",13,10,"Buffer pointer:     %p"
                dd Sound.BufferPtr
                db "hh (8k)",13,10,"Sample rate:        %p"
                dd Sound.SampleRate
                db "d",13,10,"Bits per sample:    %p"
                dd Sound.Bits
                db "d",13,10,10,"%",0
