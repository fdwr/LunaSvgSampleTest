_______________________________________________________________________________
ScratchPad of random ideas
_______________________________________________________________________________
This information is inconsistent with the current GUI compilation, and
serves as a random reference and scratchpad for miscellaneous ideas.
Some of the ideas in here are outdated, while others are only dreams waiting
realization.

_______________________________________________________________________________
Basic Gui Item

-What makes up a GUI Item-
Every GUI item is a combination of code, unique data structure, GUI item
information, container, and owner. The data structure type and related code
will vary for different kinds of items, but all of them, whatever they are
and however they react, share the same GUI information structure. For example,
buttons, lists, and text prompts all behave quite differently, but all have
in common certain attributes like size, position, visibility, and key focus.

-Items vs Objects-
Note that I call them 'items' rather than 'objects' because (1) I think the
word 'object' is overused, (2) the very word object comes from the latin
'obicere' meaning to throw in the way, present, hinder, which is exactly what
I think today's extreme object-oriented programming tends to do, and (3)
indeed most 'objects' are not independant objects at all - rather they depend
on other objects (child and parent) very much for their proper operation.
Instead of thinking of them as their own unattached entities, I think of them
as items in a list, with the container holding that list.

-GUI/Item information separation-
Originally I separated the GUI information (height/width/top/left/owner...)
from the item's data structure (like a list's variables for the number of
rows and columns, the scroll position, which one is currently selected...).
That required two data structures to be passed around for every function and
message. It also required keeping track of and using two pointers in all the
item code.

-Combining GUI and Item information-
My latest thought is to combine the two into one data structure, with the
unique variables for each item 'subclassed' onto the generic GUI information.
In case any future changes need to be made to the GUI information though, it
would make recompilation easier if the basepoint of the combined structure
(offset 0) started in the middle, so that all the variables for every item
type wouldn't need to be resequenced. This would make all item specific
variables relative to +0, and all item GUI variables negative.


item data ptr
  Pointer to the item's data structure, a combination of GUI information and
  item specific variables. The GUI information holds all the common
  variables that every GUI item needs, while the item variables store
  information unique to that item - such as whether a button is currently
  pressed or how many entries are in a list. The message handling code can be
  obtained from this structure.

item code
  Item's main message handler routine which all messages are directed to,
  regardless of the type of message or where they are sent from, whether
  the main program, the container, or even other items. Passed to this code
  address is a message, the item's data ptr, and other optional parameters
  (depending on the message). Usually the item code is directly associated
  with the corresponding item type, but it is possible for intercepting code
  to be called first. Then, after its own processing, it could either ignore
  the message or jump to the item's default message routine.

container ptr
  Pointer to gui item data of containing window. Using this structure, the
  message handler address of the container is called. All frequently sent GUI
  messages, such as NeedRedraw, Move, SetKeyFocus, are sent to this handler
  and quietly handled, rather than bombarding the main program.

owner code
  Code that responds to changes in the object's data structure. The owner is
  a message handling routine in the main program that needs to perform an
  action when some important event occurs to the item, like a button being
  pressed or menu choice being selected. Instead of program code, the owner
  may also be another item. For example, the scroll bar alongside a list is
  owned by that list (don't confuse owner with container). The ptr to owner
  must NEVER be null, but can be NullGuiItem if changes in that item are
  unimportant. Passed to the owner's code address is a message, the owner's
  data structure (if applicable), and the data structure of the owned item.
  The item's container is never bothered with such item specific messages.

top/left
    Top/left coordinate within parent (not the screen).

height/width
    Size in pixels.

attribs
    32 flags that hold various attributes for the object.

________________________________________
Message Parameters

All of these consist of a message, ptr to item information, and optional
additional parameters or pointer to more message information.

Events Received Parameters: (to item, from container/owner/other item)
  Message (register)
  Item's data structure ptr
  More parameters or ptr to more information...

  - A simple message, such as a keypress, can hold all of its useful
    information in a single register. More complex messages either push more
    parameters onto the stack or use a pointer to the rest of the message.

Events Sent Parameters: (from item, to containing window)
  Message (register)
  Container's data ptr
  More parameters or ptr to more information...

  - The third parameter is commonly the index of the item sending the
    message.

Data Changed Parameters: (from item, to owner)
  Message (register)
  Item's data structure ptr
  More parameters or ptr to more information...

  - The owner uses the same data structure as the owned item.

________________________________________
Flags

Null
  no object is associated with the GUI entry. used for quickly clearing an
  item in a container list without shifting every entry after it down one.
  when this flag is set, messages are never sent to it, since the code/data
  ptr may be invalid and using them could cause a program crash. also, all
  other flags must be ignored. for example, if an object is null, it can
  not be the start of a tab group, even though that bit may be set.
Hidden
  never seen as they do not receieve redraw messages, but can still
  keyboard or timer input. when an object is hidden, it's position and size
  must be considered possibly invalid and not used for anything. therefore
  mouse input is never sent to a hidden object (unless specifically grabbed
  by SetMouseFocus).
//Disabled
//  does not respond to mouse or keyboard input, but can still receive timer
//  input, such as an animated item. they can not be 'tabbed' to or ever
//  receive focus via a message. disabled can be shown in how the object
//  draws itself (such as a grayed out button).
MouseFocus
  all mouse input is directed to item, because the cursor is currently over
  the item or because the item specifically grabbed mouse focus.
NoMouseFocus
  item can't receive mouse input. item is ignored when mouse messages are
  sent out, even if the item is directly under the cursor.
KeyFocus
  depending on how NoKeyFocus is set, this bit means either the item
  currently has focus and all keyboard input is directed to it (key focus
  allowed), or that it is simply set active for appearances purposes (no key
  focus). Thus it is possible for more than one item to appear active, but
  only one has key focus. in item pairs, such as a combined text prompt and
  list, the input is not sent to either directly, but rather to a hidden
  item which then directs the input to the correct item. so the hidden item
  would have focus while the text prompt and list would appear active (as if
  they both simultaneously had focus).
NoKeyFocus
  item can't get key focus by being tabbed to. it can still be set to
  appear 'active' though.
ItemActive
  depending on how NoKeyFocus is set, this can bit can mean either the item
  the default/active item of its group (key focus allowed), or that the item
  should automatically receive focus whenever its containing group does (no
  key focus). Every group has its own default item, so this bit being set is
  no indication that the item has key focus.
GroupActive
  depending on how NoKeyFocus is set, this can bit can mean either the item
  is part of a group which currently has focus (key focus allowed), or that
  the item should automatically receive focus whenever the container does
  (no key focus). Although there can only be one group set, the container
  may not currently have focus, so this bit being set is no indication the
  item has key focus. Except for items in the active group, title bars are
  only item that use this bit, to automatically become active along with the
  window.
GroupStart
  indicates first item of a group.
Redraw
  tells container the item needs to be redrawn. the item will be redrawn the
  first chance the container gets, starting with a message at the top that
  cascades down to each container and each item within them. with this flag
  set, the item will only be clipped within the screen boundaries and the
  container. items must NEVER redraw themselves whenever they feel like it,
  (because of the main loop's structure), but instead inform the container
  and wait for it to later return a redraw message.
RedrawBg
  tells container that the background behind object must be redrawn before
  redrawing the whole object. the object may be clipped within itself,
  depending on what parts of it need to be redrawn.

________________________________________
Key Focus

Unlike Windows with its simple focus in and focus out (GotFocus/LostFocus)
messages, my GUI has varying levels of focus: container, group, and item.
Since there are three different levels of focus with two possible directions
each (in/out), rather than have six different messages, they are all
signaled by a single generic FocusChange message. The item then simply needs
to test its flags to tell what has changed, if it should pay attention to or
ignore the change, and what direction it changed to (focus in/out).

Item focus change:
  release focus from active item and set focus to new item.
Group focus change:
  Release all objects in previous group, except those with GroupActive.
  Find default item of new group to receive focus. If no default item is set
  for that group, set the first enabled item. A group focus change can not
  happen if all items in the new group are disabled or can not receive key
  input.
Container focus change:
  If container gets focus, set active item, active group, and any items with
  ActiveGroup flag set. If container loses focus, release focus of active
  item, clear active flag of group, and clear active flag of any items with
  ActiveGroup flag set

________________________________________
Messages

Redraw
  received from container as an echo for the item needing
  to be redrawn. the item should not actually redraw
  itself until receiving this message. depending on what
  flags are set, this indicates either a partial or
  complete redraw. complete redraws are usually received
  when object is drawn for first time or when revealed
  after a window is moved out from in front of it. the
  whole item must be redrawn, excluding any clipped
  regions. the item can return the area actually redrawn,
  or just let the window assume the entire area of the
  item was redrawn.
RedrawItem
  sent from a item to container (or possibly program code)
  when the item needs to be redrawn. the item should never
  actually redraw itself until given permission by the
  container with a Redraw message. depending on what flags
  are set, the item may let its parent know that the
  background in the item's space needs to be redrawn first.
  then, when the container receives its own Redraw, it will
  first draw its background (whether a solid background
  color, picture, or texture) before echoing the messages to
  its contained items. the reason why item Redraws must be
  done only when the item receives a Redraw messages (rather
  than when an event occurs) is because of the redraw method
  used, the painter's algorithm. for everything to appear
  correctly layered, all the container's and items within them
  must be called back to front. redrawing only once a frame is
  also done so that the program does not fall behind in input.
  some slow programs you can watch perform actions even after
  you have released the key, or worse, they completely miss
  keys. by not redrawing (one of the slowest operations) after
  every significant change, speed can be increased.
KeyPrsRls
  key press or release. unlike Windows, the keyboard scan code and
  equivalent ASCII character are sent in the same message rather than two
  separate messages. Flags specify whether the event is a press/release,
  repeat key, and an ascii character exists. key releases and function keys
  (F1,F2,Home,Up,Pause) do not include ascii characters.
KeyFocus
  either gained or lost key focus, from either tabbing among items or moving
  the mouse over an item. the item can test its flags to determine what
  has changed, if it should pay attention to or ignore the change, and what
  direction it changed to (focus in/out).
MouseMove
  cursor moved over item, a commonly ignored message.
MousePrsRls
  mouse button was pressed or released.
MouseFocus
  mouse cursor either entered item's area (over item) or left item (outside).
  a mouse focus change also happens when an item specifically grabs focus
  (like capturing). the first mouse movement message sent to an item is
  always MouseFocus (in), thereafter being MouseMove's. the last message
  sent, before exiting the item's boundary, is MouseFocus (out).
//HelpOnObject
//  cursor was rested over object for a while or F1 is pressed
TimerTick
  current time equals or is greater than the item's next time increment. if
  greater, the message includes a count of how many timer calls were missed.
SetKeyFocus
    Item only, relative
    Group only, relative
    Group item, relative
    Item only, absolute
    Group only, absolute
    Group item, absolute

    Flags:
        Absolute / Relative
        Set current item / Set specified item
        Set current group / Set specified group
        Set item only / Activate container
        Activate item(s) / Get item index only
        Forward to next available item / Backward to previous
        Ignore if specified item could not be set / Advance focus

    Relative
        relative
        forward
        default
        specified

        either starting from current item or given item
        by group, ignore item
        by item of group, within window
        by default item of group, within window
        relative by item within group
        relative by default within group
        Group specified
            if yes, the given group is used
            if not, the current group is used
        Item specified
            if yes, then it is used
            it not, the current item in the determined group is used
        Direction
            forward
            backward

    Will return error if no items exist, no items are enabled, the item given
    was out of range, or the item could not receive key focus.

_______________________________________________________________________________
Redrawing

  if window area has changed, redraw background
  search all objects for any that were affected by the background redraw
  search all objects for any needing redrawing and redraw

_______________________________________________________________________________
Item Attributes

========
Window attributes
  total items
  active item
  active group
  background
  previous mouse area
  redraw area
  item list

- window Backgrounds
  0 - nothing/transparent
  1 - solid color value
  2 - single picture at top left
  4 - tiled picture for textured look

========
TextList
  source function
  source base
  previous source ptr
  previous source index
  rows (or choices)
  columns
  current position row/col
  column widths

- a text function is given a row/col (which must be valid) and returns the
  ptr to a simple character string and its length.
- generates messages when the choice is changed and when the list is scrolled.
- column widths are only included and used if there are at least two columns.

========
FileList
  exactly the same as a normal TextList except that the source function is
  fixed, the columns are always one, and the list items are displayed
  differently. Files are shown normally, but folders are shown with
  parenthesis around them. The file/folder is stored in the first byte before
  the filename.

========
TextPrompt
  text ptr		(string is not null terminated because length is included)
  text length
  caret position	(from 0 to length)
  invalid flag

- this string does not have a null.
- the invalid flag can be used to show an entered is not legal. this would
  mainly be used for numeric values that were out of range.
- generates messages when the text is changed and when the caret moves.

========
Label
  text ptr		(string is not null terminated because length is included)
  text length
  alignment base and floating
  wrap true/false
  text colors(?)

- Lines longer than the width will be wrapped if set.
- Alignment can be left/center/right combined with left/right clipping. For example, a complete path and filename would normally be left aligned when less than the maximum width, but since you would always want to be able to see the rightmost part of the path, it would also be right base aligned.
- No messages.

========
Image
  image ptr
  strech?

- Pretty simple object. Images can be transparent.

========
Attribute Item Collection
  total items
  active item
  item height/width
  item function table
    item position within object
    item type text/picture
    item name text ptr
    item function

- an item name/description is always text.
- an item function can return either a text ptr or an image depending on its
  type.
- all items share the same sized area.
- generates messages whenever the active item is changed, arrows or other
  similar keys are pressed (PgUp PgDn Home End + - * /), number key is
  pressed, or Enter is pressed.

========
Picture entity
  bits?
  transparent true/false
  transparent color
  height/width
  pixel ptr

_______________________________________________________________________________

Redrawing:

start, loop until all objects have been checked
	if object is invisible or nonexistant, clear redraw flags, skip to NextObject
	if redraw all is set
		skip to RedrawCompleteObject
	elseif object needs redrawing (partial or complete)
		if object is within redraw area, set redraw all
		-- RedrawCompleteObject:
		set clips to object extents
		redraw
		clear redraw flags
	else
		if object is within redraw area
			set redraw all
			set clips to redrawn area extents
			-- RedrawObject
			redraw
			clear redraw flags
		(else object is not redrawn at all)
		endif
	endif
	-- NextObject:
end loop


Resizing a window sets its redraw area
Deleting or moving an object sets the window's redraw area

_______________________________________________________________________________

Key Focus:

item
group
container
relative
get

Only one item have key focus at any given time in a container. Whether the
container itself currently has focus, there is always an active item.
Individual key focus items can be grouped. Each group has its own default
item.

Item only, relative
    Container will search forward or backward for next available item
    (meaning the item is not null and can recieve key focus) starting from
    the active container item and wrap within the group. Only the active item
    and default group item changes; the current group stays the same. If no
    other focus items exist, no change will occur.
Group only, relative
    Search will procede by group, wrapping within the container. The default
    group item of the new group (next or previous) is actived. If no other
    focus groups exist, no change will occur.
Group item, relative
    Search will procede by individual item, disregarding all group divisions
    and wrapping within the container. If the group of the new item is
    different from the current group, the active group will change, along
    with that group's default item. If no other focus items exist, no change
    will occur.
Item only, absolute
    Specified item within current group is set default. If the specified item
    is in the current group, the active item and default group item change.
    If the item is part of another group, the item is not activated and
    simply becomes that group's default item.
Group only, absolute
    Group containing the specified item is activated, activating the default
    item of the new group. This is convenient for activating a group without
    changing the default item of that group the same.
Group item, absolute
    Specified item of any group in container is activated.

_______________________________________________________________________________
20031220
Interface Styles (skins, but not)

Possible skins
	PikenSoft!
	Cannes
	Odyssey
	Quicktime
	Java
	Mplayer8
	Mplayer9 Corona
	Mac Aqua
	BeOS

	WinAmp 3
	Sakura - No Strings Attached
	Kalak shiny
	H2O Equilibrium
	Win 98


Item States
	Have four basic states: normal, hovered, pressed, and disabled.
	Individual types may have more or fewer states.	Each state can
	have its own look, but if one is not given for the specified
	item, it defaults to one that is.

	normal (if not given, a very basic control is drawn)
	hovered -> normal
	pressed -> hovered -> normal
	disabled -> normal

Multiple parts
    Items that are typically standard sizes (like push buttons) can get away
    with a single size image. Most types though require multiple parts, often
    needing at minimum: a middle section, four edges, four corners, and a text
    part. If a part is missing, it either simply will not be drawn, or other
    parts will be resized to accommodate by streching or tiling.

Multiple layers
    Each part can consist of multiple layers, each layer having its own
    image and attributes. The first layer always has information about the
    part itself and it often contains a hittest bitmap so that hittesting can
    be done quickly, rather than it needing to search the entire layer array.
    The bottom layers always come first so that layers can be drawn bottom up
    (good old painter's algorithm).

    Ex: lower right corner of a menu
        layer 0 - part size and hittest [static]
        layer 1 - shadow [subtract]
        layer 2 - edge [copy]

Hit testing:
    Uses combination rectangle & bitmap hittesting to avoid clicking beyond
    a rounded corner.

Program differences
    Unlike WinAmp or Media Player skins, these are really more styles, like
    those of KDE, Gnome, or XP.
                                WA2 WA3 WMP KDE 9X  XP  PKUI
    Prerendered images          *   *   *   *   -   *   *
    Advanced blending ops       -   *   -   *   *   *   *
    Fast/efficient              *   -   -   -   *   -   *
    Specific window skins       *   *   *   -   -   -   *
    Individual control styles   -   -   -   *   -   *   *
    Image compression           *   *   *   ?   -   -   *
    Images stored as bitmaps    *   *   *   -   -   *   -
    Relocatable controls        -   *   *   -   -   -   -
    Scripting language used     -   *   *   -   -   -   -

    -Does not use slow scripting language
    -Supports powerful blitting operations (ones than Win has long lacked)
    -Uses custom image compression rather than simply zipping raw bitmaps
    -Loads directly into memory rather than into temp files
    -Controls look different, but stay where were originally placed
    -Styles apply to each control, so every window inherits customizations
    -Individual subclassed windows can also be custom styled

Text
	All text can have special effects applied to it, or each item can
	have its own text effects. Text can be blended with a gradient
	before being drawn to the screen, or it can have a shadow, or it
    can be translucent...

Blitting operations
	copy - source copied over destination (d = s)
    copy keyed - copies only opaque pixels (d = s if not -1)
    copy mapped - copies indexed image using given palette (d = pal[s])
    copy key mapped - convenient combination of above two operations
	add - source added to destination (d += s)
	subtract - source subtracted from destination (d -= s)
	multiply - source multiplied into destination (d *= (s\f))
	alpha - source applied to destination (d *= (s\256))
	blend - two images and pixel weights (d = s+(d-s)*a)
	low - lesser of two pixel values (d = (s<d) ? s:d)
	high - lower of two pixel values (d = (s>d) ? s:d)
    hit test - (nothing drawn)
    monochrome - create monochrome image (d = (r+g+b)*c\f)
    glow - highlight outer edge
	nop - no operation

    source      1   8  32 | 1   8  32 | 1   8  32 |
    dest        1   1   1 | 8   8   8 | 16  32 32 | (actually 15bit)
    -----------------------------------------------
    copy opaque           |     *     |         * |
    copy trans            |     *     |         * |
    copy mapped           |     *     |     *     |
    add                   |     *     |         * |
    subtract              |     *     |         * |
    multiply              |           |     *   * |
    blend                 |           |         * |
    alpha                 |           |     *   * |
    low         *         |     *     |         * |
    high        *         |     *     |         * |
    monochrome            |         * |         * |
    glow                  |     *     |           |
    hit test    -   -   - | -   -   - | -   -   - |
    nop         -   -   - | -   -   - | -   -   - |

    ?invert - inverts brightness (d = 1-d)

Image elements
    combine operation (copy, add, alpha, glow..., hittest, nop)
	bitdepth (1-monochrome mask, 8-byte alpha mask, 15-high color)
    flags (tiled, streched, fixed, center, tile integral, left, last, alphaed, no bg redraw)
    layer id
	pixel ptr
	height 
	width
	x offset (also useful for hotspot)
	y offset

Border type ideas
	Rounded purple line separating white inside purple.
	Thin green cross tip, with light blue alpha interior. Light faint shadow on right.
	Purple gel.
	Sharp black in dark gray.
	Sharp LCD tan in white, with triangle in corners.
	Raised glass bubble. Mac Aqua.
	Rounded convex with light gray in cloudy sky.
	Win3.11/95/XP
	Soft blue glow around black.
	Watery ridge.


Button type ideas
	Thin golden ring with inner blue marble.
	Shiny blue glass. Mac Aqua.
	Pure text/symbols when normal. Shaded when hovered or pressed.
	Translucent blue circles.

Slider type ideas
	Slitted light gradient.
	Paralellogram.
	Bright small dot.

Scroll bar type ideas
	Blue difuse bubble inside glass rounded tube.
	No bar. Just triangular arrow.

Title bar type ideas
	Multiple long, thin, horizontal bars.
	Dip from thin top, title centere.
	Down slope wedge on both sides
	Wavy connectors on sides
	Top half black and bottom half of text open
	Rounded rectangle on right side

Toolbar type ideas
	Indented square around whole
	Slanted etched divider between neighbors


_______________________________________________________________________________
20040215

New GUI item. Will not use ebx as heavily. Messages will no longer be
passed using eax for the sake of outside C routines.
Item's object (data and code pointer) will still be passed as the
first parameter.

new stack order:
esp+12	optional parameters
esp+8	message
esp+4	item data
esp+0	return address

Stack will still be removed by the caller (_cdecl) so that any number
of parameters can be passed, and so that an object will not crash just
because it receives an unknown message and thus does not know how to
adjust the stack.

PkuiTextEdit( object, message, mousepress )
object->code( object, message, mousepress )

Code can be called through either its object interface, or directly if the
static address is known.

_______________________________________________________________________________
20040216

New image layer	requires more attributes for scaling and tiled modes,
including clipping and alignment to any facet.
Alignment options:
top of section (like the handle of a scroll bar)
top of item (like the handle of a scroll bar, but aligned to the control)

_______________________________________________________________________________
20040424

Forget 15bit. Just make everything 32bit. Will greatly simplify transparency.

_______________________________________________________________________________
20040523

Definitions and synonyms

Component, Item, Window, Framework, Element, Section, Sector, Segment, Member
Foundation

verge, border, edge, margin

limits, range, bounds

brim, brink, edge, fringe, margin, perimeter, rim, skirt, verge

index, list, registry, inventory

index, mark, sign, token

factor, division, member, component, construction

range, gamut

item - an object of attention, concern, or interest
	a distinct part in an enumeration
	a separate piece of news or information
control - a device or mechanism used to regulate or guide the operation of 
	a machine, apparatus, or system 
list - a simple series of words or numerals 
catalog - a complete enumeration of items arranged systematically with 
	descriptive details 
index - a device that serves to indicate a value or quantity 
	number or symbol associated with another to indicate mathematical operation
	to be performed or to indicate use or position in an arrangement
token - a distinguishing feature 
	a small part representing the whole 
note - written or printed matter accompanying an article to furnish
	identification or other information
	a descriptive or identifying word or phrase
register - a written record containing regular entries of items or details
range - the difference between the least and greatest values of an attribute
	or of the variable of a frequency distribution
limits - a prescribed maximum or minimum amount, quantity, or number
edge - the line where an object or area begins or ends
margin - the outside limit and adjoining surface of something 
border - an outer part or edge
brim - an upper or outer margin
verge - something that borders, limits, or bounds
	an outer margin of an object or structural part 
skirt - a part or attachment serving as a rim, border, or edging
	the rim, periphery, or environs of an area 
frame - the constructional system that gives shape or strength 
	such a skeleton not filled in or covered
gamut - an entire range or series


Hmm, object is overused. Control is valid, but insufficient. Item is good but
easily confused subitems, like elements of a text list.

_______________________________________________________________________________
20040704

Possible text decorations:
Underlined, Italic slant (typical font styles)
Background highlight (Windows system list)
Shadow (WinXP title bar)
Grow, Strech (size distortions)
Grow (some hovered buttons)
Dashed outline (Windows 9x buttons)

Images are now separated into layers and images.
Layers contain all the blend mode, alignment, and filter information.
Images contain solely image info and pixel data.

Layer elements:
	blend operation (opaque, add, alpha, glow..., hittest, nop)
	flags (last, tiled, streched, aligned...)
	layer id?
	depth?
	left side
	top side
	right side
	bottom side

	1		blend operation (opaque, add, alpha, glow..., hittest, nop)
	3		flags
			-last
			-strech/tile/static
			-alignment
	4		image ptr
	4	2	left side
		2	top side
	4	2	right side
		2	bottom side

New Image elements:
	1		type / flags
	1		bitdepth (1-monochrome mask, 8-byte alpha mask, 15-high color)
	2		byte wrap
	4		pixel ptr
	4	2	height
		2	width
	4	2	? x offset (also useful for hotspot)
		2	? y offset

_______________________________________________________________________________
20040712

After considering many choices (mostly variations of Piken+GUI) decided on Pigeon.
Wanted a name that was not serious but not dumb either, and all the names with GUI.
Wanted a short Luna and Aqua are fine names for styles, but I needed a name
It's a funny little name after a funny little bird.

[Pi]ken's [G]raphical [E]nvir[on]ment

_______________________________________________________________________________
20040721

The name 'pigeon' did not last long - sounds silly. Chose instead 'plain'.
This name uses the more appropriate 'interface' instead of 'environment',
makes special note of its layered approach, and homonym of 'plane' which
is fitting since it is a 2 dimensional GUI.

[P]iken's [La]yered [In]terface
_______________________________________________________________________________
20040721

Will move GUI object code pointer from -4 to 0, so that C functions can call
entry points more easily.

