Random thoughts for the future:

TODO:
    - Add option to display size label or not
    - Wrap labels correctly if too narrow, paired with image
    - Add 'switch' element too.
    - Support non-square SVG's
    - Upload LunaSvg changes:
        - (fixed locally) Blank canvas treated as blank
        - (fixed locally) Missing em and ex from switch statement property.cpp Length::value
        - (defer until SVG2 published?) Unknown elements treated as g
        - (fixed locally) Clear faster
        - (added locally) enumerate contours
        - Eventually grid fitting

Fix void Canvas::rgba() to use macros. canvas.cpp line 195
    plutovg-private.h
    #define plutovg_alpha_shift 24
    #define plutovg_red_shift 0
    #define plutovg_green_shift 8
    #define plutovg_blue_shift 16

Gridfitting prototype - add extended SVG attributes for gridfitting
    Anchor points
        Invisible points solely for anchoring other shape's points to
        It has no fill, stroke, or visibility.
        Bounding box and clipping path calculations do not apply (so getBBox, getBoundingClientRect, getClientRects). Though SVG editors may have a more inclusive bounding box to show anchors.
        Pointer or keyboard events do not apply.
        Anchor sets contain multiple anchors, each potentially with different rounding modes
            1 point yields translation
            2 points yield uniform scaling along both axes - for asymmetric scaling, use 3 (e.g. x=10,y=20 to x=30,y=20)
            3 points yield arbitrary transformation (asymmetric scaling, shear, rotation)
            4+ points are unsupported, but a future version could treat them like a mesh warp.
    Grid fitting
        Align group of objects to adjusted/aligned point
        Translate anchor and entire grouped object and then stretch by other anchor
        transform-grid(translate(...) scale(...)
    Rounding
        Modes:
            floor, ceil
            halves to nearest floor or ceil
            toZero, toInfinity
            in, out
            up, down, left, right
        rounding-origin for in (toward zero) and out (toward infinity) rounding, or maybe an offset inside the rounding mode. e.g. to-zero(x 0 -23 0)
        inward and outward rounding based on path direction clockwise vs counterclockwise
        Round relative another point
        Round even/odd (e.g. 1/3/5 odd pixel lines to half pixel vs 2/4/6 even pixel lines to pixel intersection) grid-rounding="evenodd(2)" or odd-shift(2)
        Round at a fraction of the grid, such as half pixels grid-rounding="x floor half"? grid-scale="0.5 0.5"? grid-transform="scale(0.5 0.5)"
        No rounding mode supported for halves toward even numbers (also called "banker's rounding" or "convergent").
        Round conditionally depending on whether axis aligned. e.g. grid-rounding="axis-aligned(x) non-axis-aligned(y)" 
        Reinterpret rounding direction depending on rotation or mirroring, such that a mirrored/rotated graphic looked the same as a rotated/mirrored bitmap. reinterpet-on-transform(true)
        At the lower level, these resolve to bit flags: enabled/disabled per axis, floor/ceil, enabled when axis aligned true/false, flip on winding orientation, reinterpret on transform (default true) 
    Conditional details
        Conditional visibility based on device pixels per canvas unit (PPU)
        If the condition is false, all children are hidden too (more like display:none than visibility:hidden).
        If applied to an anchor, that anchor is not considered part of the rendering tree, and any children depending on it behave like a nop.
        Possible differences:
            Omit details like drop shadow
            Perspective orientation when the icon is large, but flat when tiny (e.g. Windows 7 Notepad in Alt+Tab vs top left system icon)
            Fewer objects, such as a pad with pencil at large sizes but just the pad for smaller sizes.
    Minimum constraints
        Set minimum path width minimum-strokewidth="1px" (e.g. no thinner than 1 pixel)
        Ensure minimum 1-pixel gap between lines (e.g. Outlook office calendar icon)

Read:
    A vector format for Flutter by Google - https://docs.google.com/document/d/1YWffrlc6ZqRwfIiR1qwp1AOkS9JyA_lEURI8p5PsZlg/edit#heading=h.8crpi5305nr
    Rendering good looking text with resolution-independent layout - http://people.redhat.com/otaylor/grid-fitting/
    https://yqnn.github.io/svg-path-editor/
    https://svg-path-visualizer.netlify.app/
    Understanding grid sizes of (SVG) icons - https://makandracards.com/makandra/467222-understanding-grid-sizes-of-svg-icons

Investigate callstack for pixel coordinate rounding / grid-fitting:
    lunasvgtest.exe!sw_ft_outline_convert(const plutovg_path * path, const plutovg_matrix_t * matrix) Line 128	C
    lunasvgtest.exe!plutovg_rle_rasterize(plutovg_rle_t * rle, const plutovg_path * path, const plutovg_matrix_t * matrix, const plutovg_rect_t * clip, const plutovg_stroke_data_t * stroke, plutovg_fill_rule_t winding) Line 268	C
    lunasvgtest.exe!plutovg_fill_preserve(plutovg * pluto) Line 464	C
    lunasvgtest.exe!plutovg_fill(plutovg * pluto) Line 426	C
    lunasvgtest.exe!lunasvg::Canvas::fill(const lunasvg::Path & path, const lunasvg::Transform & transform, lunasvg::WindRule winding, lunasvg::BlendMode mode, double opacity) Line 111	C++
    lunasvgtest.exe!lunasvg::FillData::fill(lunasvg::RenderState & state, const lunasvg::Path & path) Line 332	C++
    lunasvgtest.exe!lunasvg::LayoutShape::render(lunasvg::RenderState & state) Line 409	C++
    lunasvgtest.exe!lunasvg::LayoutContainer::renderChildren(lunasvg::RenderState & state) Line 88	C++
    lunasvgtest.exe!lunasvg::LayoutGroup::render(lunasvg::RenderState & state) Line 180	C++
    lunasvgtest.exe!lunasvg::LayoutContainer::renderChildren(lunasvg::RenderState & state) Line 88	C++
    lunasvgtest.exe!lunasvg::LayoutSymbol::render(lunasvg::RenderState & state) Line 160	C++
    lunasvgtest.exe!lunasvg::Document::render(lunasvg::Bitmap bitmap, const lunasvg::Matrix & matrix, unsigned int backgroundColor) Line 212	C++

    lunasvgtest.exe!lunasvg::to_plutovg_path(plutovg * pluto, const lunasvg::Path & path) Line 293	C++
    lunasvgtest.exe!lunasvg::Canvas::fill(const lunasvg::Path & path, const lunasvg::Transform & transform, lunasvg::WindRule winding, lunasvg::BlendMode mode, double opacity) Line 106	C++
    lunasvgtest.exe!lunasvg::FillData::fill(lunasvg::RenderState & state, const lunasvg::Path & path) Line 332	C++
    lunasvgtest.exe!lunasvg::LayoutShape::render(lunasvg::RenderState & state) Line 409	C++
    lunasvgtest.exe!lunasvg::LayoutContainer::renderChildren(lunasvg::RenderState & state) Line 88	C++
    lunasvgtest.exe!lunasvg::LayoutGroup::render(lunasvg::RenderState & state) Line 180	C++
    lunasvgtest.exe!lunasvg::LayoutContainer::renderChildren(lunasvg::RenderState & state) Line 88	C++
    lunasvgtest.exe!lunasvg::LayoutSymbol::render(lunasvg::RenderState & state) Line 160	C++
    lunasvgtest.exe!lunasvg::Document::render(lunasvg::Bitmap bitmap, const lunasvg::Matrix & matrix, unsigned int backgroundColor) Line 212	C++

    lunasvgtest.exe!plutovg_matrix_map_point(const plutovg_matrix_t * matrix, const plutovg_point_t * src, plutovg_point_t * dst) Line 128	C
    lunasvgtest.exe!sw_ft_outline_convert(const plutovg_path * path, const plutovg_matrix_t * matrix) Line 108	C
    lunasvgtest.exe!plutovg_rle_rasterize(plutovg_rle_t * rle, const plutovg_path * path, const plutovg_matrix_t * matrix, const plutovg_rect_t * clip, const plutovg_stroke_data_t * stroke, plutovg_fill_rule_t winding) Line 268	C
    lunasvgtest.exe!plutovg_fill_preserve(plutovg * pluto) Line 464	C
    lunasvgtest.exe!plutovg_fill(plutovg * pluto) Line 426	C

Elements:
    anchor - invisible point used for other shapes to align/fit to.
    anchor-set - set of 1 to 3 anchors used to align/fit shapes (translation, scaling, arbitrary)

Attribute:
    grid-fit - fit potentially multiple points via scaling (stretch/scale) to display pixel grid
    grid-align - align via translation to display pixel grid, passing an anchor name or coordinates.
    grid-origin - relative origin in user coordinates. When anchor names are given, it's relative to the snapped position, not the original.
    grid-offset - adjustment in device pixels, such as shifting to a half pixel.
    grid-scale - multiplier for the device grid, such as rounding to every half pixel instead.
    grid-transform - apply multiple transformation matrix operations (scale, offset, shear) to the grid's tranform (not the general shape transform).
    grid-rounding - left/right/up/down/in/out/floor/ceil/to-infinity/to-zero (combined modes: nearest-left, center-down, nearest-center-right, evenodd, evenodd-left)
    grid-transformation-interaction - whether to reinterpret the rounding mode based on rotation/mirroring (defaults true).
    path anchors - list of anchors used within the path (referred to by number 0 to N-1 within the path)
    path d - augmented to include new per-point anchors. Existing path letters include "MmLlHhVvCcSsQqTtAaZz". So use "Gg" or "ga" and "gf" (grid align and grid fit).
    ppu-range - display the object if the pixels per unit is within this range (upper bound exclusive). Can be used inside a switch statement or by itself (alternate name required-ppu?).

    todo: like-this or likeThis? SVG is a goofy mix of the two.

Attribute details:
    grid-rounding: e.g. `floor(x 0.5 2 -0.5) ceil(y)`, `up left` or `x floor prebias(0.5) scale(2) postbias(-0.5) min(1 otherAnchor); y ceil`, `up left`
        main equation:
            if world transform is axis aligned or rounding does not require axis aligment
                if transform reinterpretation matters
                    swap axes if rotated 90 or 270
                    mirror axes if mirrored or rotated 180
                if direction inversion matters
                    if line direction negative xor winding direction inverted
                        reverse mode function
                axisRoundedValue = modeFunction((axisValue - prebias) / scale) * scale - postbias)
                todo: subtract or add postbias? Does +prebias -postbias also work?
                todo: consider even/odd parity shift and rounding lines to nearest tangent (e.g. a 1.5 pixel wide vertical line left or right)
                orthogonalAxisValue += (axisRoundedValue - axisValue) * slope of perpendicular edge
        transform order:
            1. world transform              [[sx, hy ], [hx, sy ], [dx, dy ] nop if identity
               (now in screen space)
            2. anchor(s) grid fit/align
                a. nop                      [[1,  0  ], [0,  1  ], [0,  0  ] nop
                b. translate                [[1,  0  ], [0,  1  ], [dx, dy ]
                c. scale & translate        [[s,  0  ], [0,  s  ], [dx, dy ]
                d. arbitrary                [[sx, hy ], [hx, sy ], [dx, dy ]
            3. prebias(dx dy)               [[1,  0  ], [0,  1  ], [dx, dy ] nop if dx = 0 and dy = 0
            4. inverse scale(s)             [[1/s,0  ], [0,  1/s], [0,  0  ] nop if s = 1
            5. floor/ceil/none              [[1,  0  ], [0,  1  ], [dx, dy ] nop of 'none' rounding mode
            6. size scale(s)                [[s,  0  ], [0,  s  ], [0,  0  ] nop if s = 1
            7. delta multiplier(dx dy)      [[sx, hy ], [hx, sy ], [0,  0  ] nop if identity (useful for proportional delta multiple)
            7. postbias(dx dy)              [[sx, hy ], [hx, sy ], [dx, dy ] nop if identity
            ? can prebias/postbias refer to an anchor name? e.g. prebias(someAnchor) It could be useful to align one shape to another or to force a minimum distance.
        primitives:
            none - no grid rounding along x or y. e.g "x none; y floor"
            floor - round to nearest integer toward negative infinity (equivalent to floor(xy)). Can specify prebias, scale, and postbias: x(floor 0.5 2 -0.5) y(ceil)
            ceil -  round to nearest integer toward positive infinity
            to-infinity - round away from zero (toward positive or negative infinity) to nearest integer. Equals iif(x > 0, ceil(x), floor(x)).
            to-zero - round toward zero to nearest integer (equivalent to to-zero-y and to-zero-y). Also called "truncation". Equals iif(x > 0, floor(x), ceil(x)).
            bias - combo of both that applies to both prebias and postbias. e.g. bias(0.5) equivalent to prebias(-0.5), postbias(0.5)
            prebias - amount to add (subtract?) to coordinate before applying scale
            postbias - amount to add (subtract?) to coordinate after applying rounding and scale. If single parameter, then it's the x/y/xy value. If two passed, x then y. If 6 passed, then it is the full transform including proportional shift.
            scale - a scale factor to divide by before flooring/ceiling, and then remultiply (e.g. to floor to the nearest multiple of 2). There is no prescale/postscale equivalent to bias, as it would yield nonsense.
            even - todo: somehow turn this into evenodd scaled by current ppu (pixels per unit/user coordinate).
            odd - todo: somehow turn this into evenodd scaled by current ppu (pixels per unit/user coordinate).
            min? - todo: somehow integrate minimum distance from other anchors into this. Can this be achieved via prebias and scale instead? e.g. for min(2 otherAnchor) use prebias(-otherAnchor) scale(2) prebias(otherAnchor)
            axis-alignment-matters - only apply the rounding when it is axis aligned, including straight lines (horizontal/vertical) and bezier nodes with straight handles.
            axis-alignment-ignored - apply the rounding even when not axis aligned
            direction-inverted - the line direction reverses interpretation. e.g. floor(x) is treated as ceil(x) for a line going up (negative) vs down (positive).
            direction-ignored - the line direction does not matter. floor is floor, ceil is ceil.
            winding-inverted - treat direction-inverted so that lines going down as reverse interpretation. Unclosed paths or polylines are treated as if closed.
            winding-ignored - ignores the winding direction
            proportional - "tangent"? adjust the axis proportional to the displacement of the other axis, following the contour of the vertex. e.g. Consider the letter A's T-junction on the horizontal bar, where aligning y vertically to a whole pixel without also adjusting x would distort the shape and give an awkwardly thin/thick stem near that T junction. proportion(0.2 1)
            position based on object size? e.g. anchor-position="0% 100%" for left top. Or maybe anchor-points="0,0 40,0 40,20" to directly use an implicit anchor.
            Should anchor-rounding be a separate attribute in that case to avoid points also being rounded?
            ?round along a given vector. Consider an octagon where the top left line might need to move orthogonal to the 45-degree line rather than along x and y axes.
            ?proportional is essentially a form of postbias (or maybe it literally is the m12 and m21 fields of the postbias transform).
             it's useful for a pair of open scissors or the tab of a manilla folder where pure rounding would distort the 45-degree line shape.
             useful for icons8-fluency-windows-calendar.svg to ensure dots are even spaced apart, so the outer dots are spaced as much as the distance between the inner dots.
            ?round proportionally based on adjacent line segment angle rather explicit proportion keyword which would require a different value per each point and be far more tedious?
            ?round only if at least a given ppu? can this be achieve via anchors with ppu-range?
        aliases:
            left - snap to nearest pixel integer coordinate left from x, if not already perfectly aligned. Equals floor(x).
            right - snap to nearest pixel integer coordinate right from x, if not already perfectly aligned. Equals ceil(x).
            up - snap to nearest pixel integer coordinate up from y, if not already perfectly aligned. Equals floor(y).
            down - snap to nearest pixel integer coordinate down from y, if not already perfectly aligned. Equals ceil(x).
            nearest-ties-low - round to nearest integer with ties down, not banker's rounding which would yield uneven appearance. Equals nearest-left and nearest-up.
            nearest-ties-high - round to nearest integer with ties down, not banker's rounding which would yield uneven appearance. Equals nearest-left and nearest-up.
            nearest-left - snap to nearest pixel coordinate left from x and up from y (if not already perfectly aligned). Equals `ceil(x-.5)`.
            nearest-right - Equals `floor(x+.5)`.
            nearest-up - ...
            nearest-down - ...
            todo: should "nearest" name be avoided because Nearest may also mean rounded away from zero?
            center - snap to pixel center. Ties default to left and up. Equals `ceil(x-.5)+.5`. Equivalent to `ceil(xy -0.5 1 0.5)`.
            center-left - snap to nearest pixel center to the left from the x coordinate (if not already perfectly aligned)
            center-right
            center-up
            center-down
            nearest-center-left
            nearest-center-right
            nearest-center-up
            nearest-center-down
            in-cw - snap pixel inward along clockwise shape (equivalent to outward on counter-clockwise shape). e.g. in(x) out(y)
            in-ccw - snap pixel inward along counter-clockwise shape (equivalent to outward on clockwise shape).
            out-cw - ...
            out-ccw - ...
            in-cw-center - ...
            in-ccw-center - ...
            out-cw-center - ...
            out-ccw-center - ...
            in-cw-nearest-center - ...
            in-ccw-nearest-center - ...
            out-cw-nearest-center - ...
            out-ccw-nearest-center - ...
            evenodd-low - Round to pixel coordinate if even or pixel center if odd ppu. e.g. `evenodd(xy 2)`
            evenodd-high
            evenodd-left
            evenodd-right
            evenodd-up
            evenodd-down
            odd-shift?
            parity-shift?
            nearest edge shift? When stems could be closer to the left edge or right edge, choose whichever edge is closer. Maybe a subclass of parity-shift, customizable by accepting numeric parameters?
        interactions
            calc() https://drafts.csswg.org/css-values-4/#funcdef-calc and var() https://www.w3.org/TR/css-variables-1/#variables-in-shorthands are not supported inside grid rounding. This should be compatible with SVG Native which doesn't support them anyway, but all parsers must skip unknown identifers and the following content within parentheses to allow for future calls.
            axis alignment and direction inversion uses the resolved effective transform rather than the raw world transform, thus considering any active vector-effect: non-scaling-size, non-rotation, fixed-position (2022-04-19 https://svgwg.org/svg2-draft/coords.html#VectorEffectProperty)
        questions:
            How to snap diagonal lines, to either pixel centers or corners, but not midpoints between pixel centers? e.g. D:\src\Pikselai\resources\icons\icons8\icons8-color-close.svg

Example:
    Grid alignment cannot be part of the existing transform() as browsers (Chrome and Edge anyway) ignore the entire transform attribute entirely upon seeing any unrecognized calls, ruining forwards compatibility with older clients (e.g. transform="grid-align(plusSignCenter) translate(13 24)" also ignores the translate).

        <!-- icons8-fluency-add-ot-clipboard-4-sizes.svg -->
        <anchor id="plusSignTopLeftCorner" x="37.5" y="37.5" grid-rounding="up left" />
        <g grid-align="plusSignTopLeftCorner">
            <anchor id="plusSignCenter" x="38" y="38" grid-rounding="nearest" grid-multiple="0.5"/><!-- round to nearest half pixel -->
            <g grid-align="plusSignCenter">
                <circle cx="38" cy="38" r="10"/>
                <path d="m 38.5,43 h -1 C 37.224,43 37,42.776 37,42.5 v -9 C 37,33.224 37.224,33 37.5,33 h 1 c 0.276,0 0.5,0.224 0.5,0.5 v 9 c 0,0.276 -0.224,0.5 -0.5,0.5 z" fill="#FFFFFF">
                <path d="m 33,38.5 v -1 C 33,37.224 33.224,37 33.5,37 h 9 c 0.276,0 0.5,0.224 0.5,0.5 v 1 c 0,0.276 -0.224,0.5 -0.5,0.5 h -9 C 33.224,39 33,38.776 33,38.5 z" fill="#FFFFFF">

                ...
                <!-- 3 anchors are used in the path for displacement.
                     Multiple anchors can apply to multiple points,
                     such as leftPart (#0) and anotherPart (#2) applying to the last point. -->
                <path anchors="leftPart rightPart anotherPart" d="m 10 10 h20 v20 z" ext:d="an0 m 10 10 an1 h20 an0 2 v20 z"/>
            </g>
        </g>

        <svg xmlns="http://www.w3.org/2000/svg">
          ...
          <anchor id="plusSignCenter" x="38" y="38" grid-rounding="up left" />
          ...
          <g grid-align="plusSignCenter">
            <circle cx="38" cy="38" r="10"/>
            <path d="m 38.5,43 h -1 C 37.224,43 37,42.776 37,42.5 v -9 C 37,33.224 37.224,33 37.5,33 h 1 c 0.276,0 0.5,0.224 0.5,0.5 v 9 c 0,0.276 -0.224,0.5 -0.5,0.5 z" fill="#FFFFFF">
            <path d="m 33,38.5 v -1 C 33,37.224 33.224,37 33.5,37 h 9 c 0.276,0 0.5,0.224 0.5,0.5 v 1 c 0,0.276 -0.224,0.5 -0.5,0.5 h -9 C 33.224,39 33,38.776 33,38.5 z" fill="#FFFFFF">
          </g>
          ...
          <switch>
            <g ppu-range="0 16">
              <!-- less detailed version for less than 16 pixels per unit... -->
            </g>
            <g ppu-range="16">
              <!-- tiny details visible at higher ppu, at least 16 PPU... -->
            </g>
          </switch>
        </svg>

    One anchor can be defined relative to another one.
    Below, the bottom component is kept at least 1 pixel away from the top component so there is separation between them.
    todo: second anchor is relative to the rounded location rather than user coordinates, right?
    todo: should I use an explicit attribute like grid-minimum="1px" instead of rounding, that way nearest can be used?
    todo: what if you want *exactly* 1 device pixel regardless of size, not just a minimum? round up combined with minimum?
    todo: what about 45 degree angles, so that two octagons keep the same distance from each other? It's okay if the corners
    todo: should origin be the final device pixels or the user coordinates? rounding to nearest half pixel would be useful, e.g. grid-origin="0.5px 0.5px"
          are antialiased if the straight lines are snapped, and probably more important they have the same relative thickness.
          A grid-rounding attribute like "tangential" or "linear" or "fromOrigin" or "alongOriginAxis"...?
    todo: can you have relative inline anchors, such as <rect ...><anchor position="0% 100%" grid-rounding="up"/></rect> which is positioned at the left top of the rect.
          How do you align to it though? Does it need an id, just for that one case, which kinda defeats the convenience factor?
          Or <rect ... anchor-points="0% 100%" anchor-rounding="up" grid-rounding="out"/></rect> ?

        <anchor id="topComponentBottomAnchor" y="40" grid-rounding="nearest">
        <anchor id="bottomComponentTopAnchor" y="41" grid-rounding="down" grid-origin="topComponentBottomAnchor"><!-- ensure at least one pixel away -->
        <path id="topComponent" anchors="topComponentBottomAnchor" d="an m0 0 h80 an0 v40 h-80 z"/><!-- first "an" sets to no anchors, second "an" sets anchor -->
        <path id="bottomComponent" anchors="bottomComponentTopAnchor" d="an0 m0 41 h80 an v40 h-80 z"/><!-- first "an" sets anchor, second "an" resets to no anchors -->

    You can supply a scale and bias directly in the rounding mode. floor((x-bias)/scale)*scale+bias

        <g grid-rounding="floor-x(1 0.5)"><!-- round down to pixel centers -->
        <g grid-rounding="floor-x(2 0.0)"><!-- scale grid by 2x -->
        <g grid-rounding="floor-x(2 -0.5 0.5)"><!-- scale grid by 2x and round to 0.5's, where 0 to 2.49 yield 0.5, 2.5 to 4.49 yield 2.5. Formula = floor((x-.5)/2)*2+.5 -->
        <g grid-rounding="floor-x(0.5)"><!-- round to every half a pixel -->

        <g grid-rounding="x floor prebias(0.5)"><!-- round down to pixel centers -->
        <g grid-rounding="x floor scale(2)"><!-- scale grid by 2x -->
        <g grid-rounding="x floor scale(2) prebias(-0.5) postbias(0.5)"><!-- scale grid by 2x and round to 0.5's, where 0 to 2.49 yield 0.5, 2.5 to 4.49 yield 2.5. Formula = floor((x-.5)/2)*2+.5 -->
        <g grid-rounding="x floor scale(0.5)"><!-- round to every half a pixel -->

    Referring to the same anchor twice in a nested group will be a nop, since the outer group
    already aligned the anchor. (but how to achieve this? how to know the outer one applied?)

        <anchor id="plusSignTopLeftCorner" x="37.5" y="37.5" grid-rounding="up left">
        <g grid-align="plusSignTopLeftCorner">
            <g grid-align="plusSignTopLeftCorner"><!-- nop since already pixel aligned -->
                <path d="m 10 10 h20 v20 z"/>
            </g>
        </g>

    You should be able to stretch components too between the bounds, which translates to a tranform scale and translate:

        <anchor id="topLeftCorner" x="40" y="40" grid-rounding="up left">
        <anchor id="bottomRightCorner" x="60" y="60" grid-rounding="down right">
        <g grid-fit="topLeftCorner bottomRightCorner">
            <circle cx="50" cy="50" r="10"/>
        </g>

    You should be able to define an anchor set comprised of other existing anchors:
    
        <anchor id="anchorA" x="40" y="40" grid-rounding="up left"/>
        <anchor id="anchorB" x="60" y="40" grid-rounding="up right"/>
        <anchor id="anchorC" x="60" y="60" grid-rounding="down left"/>
        <anchor id="anchorD" x="40" y="60" grid-rounding="up left"/>
        ...
        <anchor-set id="anchorSetA" anchors="anchorA anchorB anchorC"/>
        <anchor-set id="anchorSetB" anchors="anchorA anchorD anchorC"/>

    Or via containment? (id's on internal anchors are then unnecessary):
    
        <anchor-set id="anchorSetA">
            <anchor x="40" y="40" grid-rounding="up left"/>
            <anchor x="60" y="40" grid-rounding="up right"/>
            <anchor x="40" y="60" grid-rounding="down left"/>
        </anchor-set>

    Or via points? (which would allow in/out rounding modes)

        <anchor-set id="anchorSetA" points="40,40 60,40 60,60 40,60" grid-rounding="out"/>

    Anchor sets may only take "anchors" or "points" attributes or child anchor elements, but not more than one.
    An anchors attribute is preferred over points, and points over
        
    Can anchors have multiple points? e.g. <anchor points="40,60 40,40 60,60" grid-rounding="down left"/>
    Or should anchors only ever be 1D points? And only anchor sets allow "points" attributes?
    It would be more concise to allow anchor with "points" and often mean only one primitive to think about <anchor>.
    Though it would be confusing if anchor allowed multiple points because when an anchor set then references an anchor, what does that mean?

    grid-fit should accept 1, 2, or 3 anchors for points, which is translation, scaling along x and y, or arbitrary scaling/rotation/shear.
    1 point is equivalent to 3 points repeating the same value.
    2 points is equivalent to 3 points with the 3rd point holding an x and y value from the other 2 points. Or 4 points making a square?
    If more than 3 points are provided, only 3 points are used to extract the affine transformation, as non-affine transforms are unsupported by most 2D renderers.

    Rotation should reinterpret rounding modes, so that the final bitmap looks identical when rotated in-place as it would if it was
    graphically rotated. There are however times where disabling that reinterpretation is useful, such as when rotating a petal
    around a flower or mirroring slats of a fence, where having consistent rounding across mirrored segments looks better.
    Attribute grid-transformation-interaction?

    Inline anchors Would a be convenient shorthand rather than needing a separate anchor each time with a unique id.
    Instead of:

        <anchor id="RectAnchor" x="23" y="42" grid-point-rounding="nearest-up nearest-left">
        <rect x1="23" y1="42" width="20" height="10" grid-align="RectAnchor">

    Just say:
        <rect x1="23" y1="42" grid-align="anchor(23 42 nearest-up nearest-left)">

    Note aligning the anchor is different from aligning all the points individually, which would change the height/width:
        <rect x1="23" y1="42" grid-point-rounding="nearest-up nearest-left">

    Naming?
        nearest-up - preferring this one
        halves-up?
        fraction-up?

        "Halves up would be confusing with existing rounding nomenclature because geometric "up" is actually numerically "down",
        whereas "halves up" means to round toward positive infinity.

    Minimum stroke:
        <circle cx="50" cy="50" r="10" stroke="#70F800" stroke-width="3" minimum-stroke-width="1px"/>

    Using the art picture frame:

    <!-- booth.pm assets arts 144-4b309d4dce8b848ec7713199ba3b782ec1915a1550f7efd179de4332d54040bd.svg -->
    <svg ...>
        <!-- top left outer, top left inner -->
        <anchor x="2"  y="10" id="clipboardTLO" grid-round="up left">
        <anchor x="8"  y="16" id="clipboardTLI" grid-align="clipboardTLO" grid-round="down right">
        <anchor x="38" y="10" id="clipboardBLO" grid-round="down left">
        <anchor x="32" y="16" id="clipboardBLI" grid-align="clipboardBLO" grid-round="up right">
        <anchor x="2"  y="38" id="clipboardTRO" grid-round="up right">
        <anchor x="8"  y="32" id="clipboardTRI" grid-align="clipboardTRO" grid-round="down left">
        <anchor x="38" y="38" id="clipboardBRO" grid-round="down right">
        <anchor x="32" y="32" id="clipboardBRI" grid-align="clipboardBRO" grid-round="up left">

        <!-- alternately use the edges instead -->
        <anchor y="10" id="clipboardTopOuter"    grid-round="up">
        <anchor y="16" id="clipboardTopInner"    grid-align="clipboardTopOuter" grid-round="down">
        <anchor y="38" id="clipboardBottomOuter" grid-round="down">
        <anchor y="32" id="clipboardBottomInner" grid-align="clipboardBottomOuter" grid-round="up">
        <anchor x="2"  id="clipboardLeftOuter"   grid-round="left">
        <anchor x="8"  id="clipboardLeftInner"   grid-align="clipboardLeftOuter" grid-round="right">
        <anchor x="38" id="clipboardRightOuter"  grid-round="left">
        <anchor x="32" id="clipboardRightInner"  grid-align="clipboardRightOuter" grid-round="right">

        <!-- starting from top right corner of picture frame, use top outer and right outer, then preceeding counter-clockwise use just top outer, then top and right... -->
        <path
            anchors="clipboardTopOuter clipboardTopInner clipboardBottomOuter clipboardBottomInner clipboardLeftOuter clipboardLeftInner clipboardRightOuter clipboardRightInner"
            d="ga 0 6 M 38,11 C 38 10.9 38 10.7 37.9 10.6 .. ga 0 H 33.3 L 22.8 2.8 C 21.1 1.6 18.8 1.6 17.1 2.8 ... g 0 2"
        />

        <!--
            Can you pass anchors to rect/circle/ellipse?
            If so, should they be relative to the corners or the edges?
            If using corners, what does it mean to pass 4 anchors if the 4th point would create a trapezoid?
            Edges may be cleaner?
            Maybe there should be no "anchors" and only a "grid-fit" (or "grid-align"/"grid-adjust").
        -->
        <anchor x="20" y="20" id="boxTopLeft" grid-round="nearest-ties-low">
        <anchor x="38" y="38" id="cicrleCenter" grid-round="odd-shift-ties-low(xy 20)">

        <rect x="20" y="20" width="10" height="10" anchors="boxTopLeft boxTopRight boxBottomLeft boxBottomRight"/>
        <circle cx="38" cy="38" r="10" anchors="circleCenter circleTopLeft circleTopRight circleBottomLeft circleBottomRight"/>
    </svg>

    Interaction with elements:
        circle cx cy rx ry - rounded how exactly?
        ellipse cx cy rx ry - rounded how exactly?
        line x1 y1 x2 y2 - each point is rounded
        polygon points="0,100 50,25" - each point is rounded
        polyline points="0,100 50,25" - each point is rounded
        rect x y width height rx ry - rounded how exactly?
        path - all points in "d" attribute rounded
        pattern x y width height viewBox - rounded after any patternTransform
        text/textPath x y dx dy - the final pixel position x+dx is rounded, not individually. If you want them separately rounded, wrap it in a <g>.
        use x y - rounded
        image x y width height - rounded
        clipPath - not affected, just subelements (e.g. the circle <clipPath id="someClip"><circle cx="40" cy="35" r="35"/></clipPath>)
        linearGradient - not affected
        radialGradient - not affected

    <switch requiredFeatures="http://www.w3.org/TR/SVG11/feature#GridFitting">
    <switch><g ppu-range="0 2"><g ppu-range="2 10"><g ppu-range="10"></switch>

    For computing ppuc along minimum axis, think of computing the minor axis length along a sheared/rotated ellipse.
        -Possibly use matrix inverse and rotate a point to axis aligned unit vector? [a b; c d] Possibly det = a*d - b*c. 2D inverse = [d -b; -c a] / det.
        -Possibly use eigen vector?
        Use this:
            numpy.set_printoptions(precision=3, floatmode='fixed', suppress=True)
            angle = math.tau * 45 / 360
            r = numpy.array([[cos(angle), -sin(angle)], [sin(angle), cos(angle)]])
            sx = numpy.array([[0.5, 0], [0, 1]])
            sy = numpy.array([[1, 0], [0, 0.5]])
            sxy = numpy.array([[0.5, 0], [0, 0.5]])
            M = R; a = M[0][0]; b = M[0][1]; c = M[1][0]; d = M[1][1]; sqrt(b*b + d*d); sqrt(a*a + c*c)
      Possibly just check x and y after rotating the transform back to axis alignment?
      Unfortunately just transforming 2 unit vectors of axis aligned x and y don't seem robust to all transformations, such as scaling along the diagonal, such as numpy.array([[ 0.707, -0.707], [ 0.354,  0.354]]).

Code snippets
    Determine winding order: https://stackoverflow.com/a/18472899/937938
    Note this won't work with the infinity sign (8) shape.

        double sum = 0.0;
        Vector v1 = vertices[vertices.Count - 1]; // or vertices[^1] with
                                                  // C# 8.0+ and .NET Core
        for (int i = 0; i < vertices.Count; i++) {
            Vector v2 = vertices[i];
            sum += (v2.X - v1.X) * (v2.Y + v1.Y);
            v1 = v2;
        }
        return sum > 0.0;

    https://stackoverflow.com/questions/22954239/given-three-points-compute-affine-transformation

        void AffineSolver(float* AtoF, float* a, float* b)
        {
            AtoF[0] = ( b[1].x * a[0].y - b[2].x * a[0].y - b[0].x * a[1].y + b[2].x * a[1].y + b[0].x * a[2].y - b[1].x * a[2].y) / 
                      ( a[1].x * a[0].y - a[2].x * a[0].y - a[0].x * a[1].y + a[2].x * a[1].y + a[0].x * a[2].y - a[1].x * a[2].y);

            AtoF[1] = ( b[1].x * a[0].x - b[2].x * a[0].x - b[0].x * a[1].x + b[2].x * a[1].x + b[0].x * a[2].x - b[1].x * a[2].x) / 
                      (-a[1].x * a[0].y + a[2].x * a[0].y + a[0].x * a[1].y - a[2].x * a[1].y - a[0].x * a[2].y + a[1].x * a[2].y);

            AtoF[2] = ( b[1].y * a[0].y - b[2].y * a[0].y - b[0].y * a[1].y + b[2].y * a[1].y + b[0].y * a[2].y - b[1].y * a[2].y) / 
                      ( a[1].x * a[0].y - a[2].x * a[0].y - a[0].x * a[1].y + a[2].x * a[1].y + a[0].x * a[2].y - a[1].x * a[2].y);

            AtoF[3] = ( b[1].y * a[0].x - b[2].y * a[0].x - b[0].y * a[1].x + b[2].y * a[1].x + b[0].y * a[2].x - b[1].y * a[2].x) / 
                      (-a[1].x * a[0].y + a[2].x * a[0].y + a[0].x * a[1].y - a[2].x * a[1].y - a[0].x * a[2].y + a[1].x * a[2].y);

            AtoF[4] = ( b[2].x * a[1].x * a[0].y - b[1].x * a[2].x * a[0].y - b[2].x * a[0].x * a[1].y +
                        b[0].x * a[2].x * a[1].y + b[1].x * a[0].x * a[2].y - b[0].x * a[1].x * a[2].y) / 
                      ( a[1].x * a[0].y - a[2].x * a[0].y - a[0].x * a[1].y + a[2].x * a[1].y + a[0].x * a[2].y - a[1].x * a[2].y);

            AtoF[5] = ( b[2].y * a[1].x * a[0].y - b[1].y * a[2].x * a[0].y - b[2].y * a[0].x * a[1].y +
                        b[0].y * a[2].x * a[1].y + b[1].y * a[0].x * a[2].y - b[0].y * a[1].x * a[2].y) / 
                      ( a[1].x * a[0].y - a[2].x * a[0].y - a[0].x * a[1].y + a[2].x * a[1].y + a[0].x * a[2].y - a[1].x * a[2].y);
        }

        https://www.w3.org/TR/SVG11/intro.html#TermConditionalProcessingAttribute

    Matrix transform of point
        https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-xform
        x = m11*x + m21*y + dx
        y = m12*x + m22*y + dy

    d:\src\lunasvgsampletest\external\lunasvg\source\property.cpp

        Transform Transform::operator*(const Transform& transform) const
        {
            double m00 = this->m00 * transform.m00 + this->m10 * transform.m01;
            double m10 = this->m00 * transform.m10 + this->m10 * transform.m11;
            double m01 = this->m01 * transform.m00 + this->m11 * transform.m01;
            double m11 = this->m01 * transform.m10 + this->m11 * transform.m11;
            double m02 = this->m02 * transform.m00 + this->m12 * transform.m01 + transform.m02;
            double m12 = this->m02 * transform.m10 + this->m12 * transform.m11 + transform.m12;

            return Transform{m00, m10, m01, m11, m02, m12};
        }

        Transform Transform::inverted() const
        {
            double det = (this->m00 * this->m11 - this->m10 * this->m01);
            if(det == 0.0)
                return Transform{};

            double inv_det = 1.0 / det;
            double m00 = this->m00 * inv_det;
            double m10 = this->m10 * inv_det;
            double m01 = this->m01 * inv_det;
            double m11 = this->m11 * inv_det;
            double m02 = (this->m01 * this->m12 - this->m11 * this->m02) * inv_det;
            double m12 = (this->m10 * this->m02 - this->m00 * this->m12) * inv_det;

            return Transform{m11, -m10, -m01, m00, m02, m12};
        }

Related:
    SVG
        SVG specification - https://github.com/w3c/svgwg/tree/master, https://www.w3.org/TR/SVG2/
        SVG Hinting Proposals - https://www.w3.org/Graphics/SVG/WG/wiki/Proposals/SVG_hinting
        Microsoft W3C rep for SVG - https://github.com/atanassov, https://www.w3.org/groups/wg/svg/participants
        https://svgwg.org/specs/svg-native/
        https://svgwg.org/svg2-draft/conform.html#secure-static-mode
    WPF
        WPF SnapsToDevicePixels and UseLayoutRounding - https://blog.benoitblanchon.fr/wpf-blurry-images/
        WPF GuidelineSets - https://www.wpftutorial.net/DrawOnPhysicalDevicePixels.html
        Images and Icons for Visual Studio - https://docs.microsoft.com/en-us/visualstudio/extensibility/ux-guidelines/images-and-icons-for-visual-studio?view=vs-2022
    TrueType
        TrueType hinting is overkill - https://docs.microsoft.com/en-us/typography/opentype/spec/ttch01
        Pushing Pixels About those vector icons - https://www.pushing-pixels.org/2011/11/04/about-those-vector-icons.html
    Tools
        Inkscape SVG editor - https://inkscape.org/
        Cairo based convertor for SVG to PNG - https://cairosvg.org/
        Cairo rendering API - https://cairographics.org/download/
        SVG Path Visualizer webpage - https://svg-path-visualizer.netlify.app/
        SVG Native Viewer - https://github.com/adobe/svg-native-viewer
    Guidance
        Material Design "Clarity (Pixel perfection)" https://material.io/design/iconography/system-icons.html#grid-and-keyline-shapes
        Adobe Spectrum Iconography https://spectrum.adobe.com/page/iconography/#Characteristics
        IBM Carbon Design System https://www.carbondesignsystem.com/guidelines/icons/contribute/
        Firefox Photon Design System https://design.firefox.com/photon/visuals/iconography.html
